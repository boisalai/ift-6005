{
  "tables": {
    "products": {
      "description": "Main table containing information about food products",
      "columns": {
        "additives_n": {
          "type": "INTEGER",
          "description": "Number of additives present in the product. Ranges from 0 (no additives) to 24 (maximum found). This count represents the total number of different additives used in a product's composition.",
          "examples": [
            "3",
            "11",
            "6"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with no additives",
              "sql": "SELECT code, product_name FROM products WHERE additives_n = 0"
            },
            {
              "description": "Get distribution of products by number of additives",
              "sql": "SELECT additives_n, COUNT(*) as product_count FROM products WHERE additives_n IS NOT NULL GROUP BY additives_n ORDER BY additives_n"
            },
            {
              "description": "Find products with high number of additives (more than 10)",
              "sql": "SELECT code, product_name, additives_n FROM products WHERE additives_n > 10 ORDER BY additives_n DESC"
            },
            {
              "description": "Calculate percentage of products with and without additives",
              "sql": "SELECT ROUND(COUNT(CASE WHEN additives_n = 0 THEN 1 END) * 100.0 / COUNT(*), 2) as percent_no_additives, ROUND(COUNT(CASE WHEN additives_n > 0 THEN 1 END) * 100.0 / COUNT(*), 2) as percent_with_additives FROM products WHERE additives_n IS NOT NULL"
            }
          ]
        },
        "additives_tags": {
          "type": "VARCHAR[]",
          "description": "An array of food additives present in the product, using standardized E-number format with 'en:e' prefix. Each element represents one additive (e.g., 'en:e330' for citric acid). Common additives include preservatives, emulsifiers, and acidity regulators.",
          "examples": [
            "['en:e330', 'en:e322', 'en:e500']",
            "['en:e211']",
            "['en:e330', 'en:e202', 'en:e260', 'en:e951']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most commonly used additives and their frequency",
              "sql": "WITH unnested AS ( SELECT unnest(additives_tags) as additive FROM products WHERE additives_tags IS NOT NULL ) SELECT additive, COUNT(*) as frequency FROM unnested GROUP BY additive ORDER BY frequency DESC LIMIT 10;"
            },
            {
              "description": "Find products containing a specific additive (e.g., E330 - Citric acid)",
              "sql": "SELECT code, product_name, additives_tags FROM products WHERE array_contains(additives_tags, 'en:e330') LIMIT 1000;"
            },
            {
              "description": "Count products by number of additives used",
              "sql": "SELECT array_length(additives_tags) as num_additives, COUNT(*) as product_count FROM products WHERE additives_tags IS NOT NULL GROUP BY array_length(additives_tags) ORDER BY num_additives;"
            }
          ]
        },
        "allergens_tags": {
          "type": "VARCHAR[]",
          "description": "An array of allergens present in the product. Each allergen is represented as a standardized tag with an 'en:' prefix (e.g., 'en:milk', 'en:gluten'). The column stores multiple allergens for a single product in a consistent format.",
          "examples": [
            "['en:milk', 'en:gluten', 'en:soybeans']",
            "['en:nuts']",
            "['en:gluten', 'en:milk', 'en:eggs', 'en:soybeans']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common allergens and their frequency in products",
              "sql": "WITH RECURSIVE unnested AS ( SELECT unnest(allergens_tags) as allergen FROM products WHERE allergens_tags IS NOT NULL ) SELECT allergen, COUNT(*) as count FROM unnested GROUP BY allergen ORDER BY count DESC LIMIT 10;"
            },
            {
              "description": "Find products containing specific allergens (e.g., both milk and nuts)",
              "sql": "SELECT code, product_name, allergens_tags FROM products WHERE allergens_tags IS NOT NULL AND array_contains(allergens_tags, 'en:milk') AND array_contains(allergens_tags, 'en:nuts') LIMIT 1000;"
            },
            {
              "description": "Find products with multiple allergens (3 or more)",
              "sql": "SELECT code, product_name, allergens_tags FROM products WHERE array_length(allergens_tags) >= 3 ORDER BY array_length(allergens_tags) DESC LIMIT 1000;"
            }
          ]
        },
        "brands_tags": {
          "type": "VARCHAR[]",
          "description": "An array of brand tags associated with the product. Each tag represents a brand name in lowercase, hyphenated format. The column can store multiple brands for co-branded products or brand variations. Common brands include major Canadian private labels like Great Value, Compliments, and President's Choice.",
          "examples": [
            "['great-value']",
            "['president-s-choice']",
            "['yves', 'yves-veggie-cuisine']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the most common brands and their product counts",
              "sql": "SELECT unnest(brands_tags) as brand, COUNT(*) as count FROM products WHERE brands_tags IS NOT NULL GROUP BY brand ORDER BY count DESC LIMIT 1000"
            },
            {
              "description": "Find products with multiple brands (potential co-branded products)",
              "sql": "SELECT code, brands_tags FROM products WHERE array_length(brands_tags) > 1 LIMIT 1000"
            },
            {
              "description": "Find products of a specific brand (case-insensitive search)",
              "sql": "SELECT code, brands_tags FROM products WHERE array_contains(brands_tags, 'great-value') LIMIT 1000"
            }
          ]
        },
        "categories": {
          "type": "VARCHAR",
          "description": "A hierarchical classification of products using comma-separated category paths. Categories can be multiple levels deep and appear in different languages (primarily English and French). Each path typically goes from broad to specific categories (e.g., 'Snacks,Sweet snacks,Biscuits and cakes').",
          "examples": [
            "Sweeteners,Syrups,Simple syrups,Agave syrups",
            "Plant-based beverages,Fruit-based,Juices and nectars,Fruit juices,Lemon juice",
            "Snacks,Sweet snacks,Biscuits and cakes,Cakes"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products in a specific category (using LIKE pattern matching)",
              "sql": "SELECT code, product_name, categories FROM products WHERE categories LIKE '%Snacks%' LIMIT 1000"
            },
            {
              "description": "Count products by top-level category (first category in path)",
              "sql": "SELECT TRIM(SPLIT_PART(categories, ',', 1)) as main_category, COUNT(*) as product_count FROM products WHERE categories IS NOT NULL GROUP BY TRIM(SPLIT_PART(categories, ',', 1)) ORDER BY product_count DESC LIMIT 1000"
            },
            {
              "description": "Find products with the most detailed categorization (most category levels)",
              "sql": "SELECT code, categories, LENGTH(categories) - LENGTH(REPLACE(categories, ',', '')) + 1 as category_depth FROM products WHERE categories IS NOT NULL ORDER BY category_depth DESC LIMIT 1000"
            }
          ]
        },
        "brands": {
          "type": "VARCHAR",
          "description": "The brand name(s) of the product. Can contain multiple brands separated by commas, often including bilingual versions (English/French) for Canadian products. Common for store brands and major manufacturers.",
          "examples": [
            "Compliments",
            "No Name, Sans nom",
            "President's Choice,Le choix du président"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common brands and their product counts",
              "sql": "SELECT brands, COUNT(*) as product_count FROM products WHERE brands IS NOT NULL GROUP BY brands ORDER BY product_count DESC LIMIT 1000;"
            },
            {
              "description": "Find products with multiple brands (typically bilingual versions)",
              "sql": "SELECT brands, COUNT(*) as count FROM products WHERE brands LIKE '%,%' GROUP BY brands ORDER BY count DESC LIMIT 1000;"
            },
            {
              "description": "Search for products by a specific brand (case-insensitive)",
              "sql": "SELECT code, brands FROM products WHERE LOWER(brands) LIKE LOWER('%Nestlé%') LIMIT 1000;"
            }
          ]
        },
        "categories_tags": {
          "type": "VARCHAR[]",
          "description": "An array of category tags that classify the product in a hierarchical system. Tags use prefixes like 'en:' for English categories and follow a general-to-specific pattern (e.g., 'en:plant-based-foods-and-beverages' -> 'en:beverages'). Each product can have multiple categories, representing various aspects like food type, processing method, dietary restrictions, and certifications.",
          "examples": [
            "['en:plant-based-foods-and-beverages', 'en:beverages', 'en:plant-based-beverages', 'en:coconut-milks']",
            "['en:snacks', 'en:sweet-snacks', 'en:cocoa-and-chocolate-products', 'en:chocolates']",
            "['en:dairies', 'en:milk', 'en:whole-milk']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count the number of products in each category to identify most common categories",
              "sql": "SELECT unnested_category, COUNT(*) as product_count FROM products, UNNEST(categories_tags) as unnested_category GROUP BY unnested_category ORDER BY product_count DESC LIMIT 1000;"
            },
            {
              "description": "Find all products in a specific category (e.g., plant-based foods)",
              "sql": "SELECT code, product_name, categories_tags FROM products WHERE array_contains(categories_tags, 'en:plant-based-foods-and-beverages') LIMIT 1000;"
            },
            {
              "description": "Find products with the most detailed categorization (highest number of categories)",
              "sql": "SELECT code, product_name, array_length(categories_tags) as category_count, categories_tags FROM products WHERE categories_tags IS NOT NULL ORDER BY array_length(categories_tags) DESC LIMIT 1000;"
            }
          ]
        },
        "checkers_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags identifying the users or systems that have checked/verified the product data. Each tag typically represents a username of a data checker or a special checking event (e.g., 'october-food-facts').",
          "examples": [
            "['pommeorange147', 'october-food-facts']",
            "['beniben']",
            "[]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find all products checked by a specific checker",
              "sql": "SELECT code, product_name, checkers_tags FROM products WHERE array_contains(checkers_tags, 'pommeorange147') LIMIT 1000"
            },
            {
              "description": "Find products that have been checked by multiple checkers",
              "sql": "SELECT code, product_name, checkers_tags FROM products WHERE array_length(checkers_tags) > 1 LIMIT 1000"
            },
            {
              "description": "Get statistics about checker activity, showing most active checkers",
              "sql": "WITH checker_counts AS ( SELECT unnest(checkers_tags) as checker, COUNT(*) as products_checked FROM products WHERE array_length(checkers_tags) > 0 GROUP BY checker ) SELECT checker, products_checked FROM checker_counts ORDER BY products_checked DESC LIMIT 1000"
            }
          ]
        },
        "ciqual_food_name_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized CIQUAL (French food composition database) food category tags that classify the product. These tags provide hierarchical food categorization and are used for nutritional analysis and product classification. Although it's an array type, products typically have only one category tag.",
          "examples": [
            "non-alcoholic-beverage-average",
            "ketchup",
            "pastry-cream-puff"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the distribution of CIQUAL food categories, showing the most common categories",
              "sql": "SELECT ciqual_food_name_tags[1] as category, COUNT(*) as count FROM products WHERE ciqual_food_name_tags IS NOT NULL GROUP BY category ORDER BY count DESC LIMIT 1000"
            },
            {
              "description": "Find products that have a specific CIQUAL food category (e.g., 'bread-average')",
              "sql": "SELECT code, product_name, ciqual_food_name_tags FROM products WHERE ciqual_food_name_tags[1] = 'bread-average' LIMIT 1000"
            },
            {
              "description": "Search for products with CIQUAL categories containing specific keywords (e.g., 'cheese')",
              "sql": "SELECT code, product_name, ciqual_food_name_tags FROM products WHERE array_contains(array_transform(ciqual_food_name_tags, x -> contains(x, 'cheese')), true) LIMIT 1000"
            }
          ]
        },
        "cities_tags": {
          "type": "VARCHAR[]",
          "description": "An array of city tags identifying locations associated with the product, typically following the format 'city-department-france'. Each tag contains the city name, its department, and country (France) in lowercase, hyphenated format.",
          "examples": [
            "nimes-gard-france",
            "cornille-les-caves-maine-et-loire-france",
            [
              "chapelle-achard-vendee-france",
              "sainte-marie-aux-chenes-moselle-france"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count number of products per city, showing most frequent cities first",
              "sql": "SELECT unnest(cities_tags) as city, COUNT(*) as product_count FROM products WHERE array_length(cities_tags) > 0 GROUP BY city ORDER BY product_count DESC LIMIT 1000"
            },
            {
              "description": "Find products associated with multiple cities, which might indicate multiple manufacturing locations",
              "sql": "SELECT code, cities_tags, array_length(cities_tags) as num_cities FROM products WHERE array_length(cities_tags) > 1 ORDER BY num_cities DESC LIMIT 1000"
            },
            {
              "description": "Find products from a specific department (e.g., Nord)",
              "sql": "SELECT code, product_name, cities_tags FROM products WHERE array_contains(list_filter(cities_tags, x -> x LIKE '%-nord-france'), TRUE) LIMIT 1000"
            }
          ]
        },
        "code": {
          "type": "VARCHAR",
          "description": "Product barcode identifier, typically following EAN-13 format (13 digits). Most codes are numeric strings starting with '0', representing standard retail product identification codes like UPC or EAN.",
          "examples": [
            "0011152156842",
            "0016600000098",
            "0018486700048"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Analyze distribution of product code lengths to identify standard formats (EAN-13, EAN-8, etc.)",
              "sql": "SELECT LENGTH(code) as code_length, COUNT(*) as count FROM products GROUP BY LENGTH(code) ORDER BY count DESC LIMIT 10"
            },
            {
              "description": "Find products with potentially invalid codes (non-numeric values)",
              "sql": "SELECT code, product_name FROM products WHERE code !~ '^[0-9]+$' OR LENGTH(code) NOT IN (8, 13, 14) LIMIT 1000"
            },
            {
              "description": "Analyze the distribution of product code prefixes to understand product categorization",
              "sql": "SELECT LEFT(code, 1) as first_digit, COUNT(*) as count FROM products WHERE code IS NOT NULL GROUP BY LEFT(code, 1) ORDER BY count DESC"
            }
          ]
        },
        "compared_to_category": {
          "type": "VARCHAR",
          "description": "Reference category used for product comparison, typically using standardized category identifiers with language prefix (e.g., 'en:'). This field enables comparison of similar products within the same category for nutritional analysis and other comparative studies.",
          "examples": [
            "en:breakfast-cereals",
            "en:virgin-olive-oils",
            "en:flower-honeys"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common product comparison categories and their counts",
              "sql": "SELECT compared_to_category, COUNT(*) as product_count FROM products WHERE compared_to_category IS NOT NULL GROUP BY compared_to_category ORDER BY product_count DESC LIMIT 1000"
            },
            {
              "description": "Get all products in a specific comparison category",
              "sql": "SELECT code, product_name, compared_to_category FROM products WHERE compared_to_category = 'en:breakfast-cereals' LIMIT 1000"
            },
            {
              "description": "Find categories that contain a specific keyword in their name",
              "sql": "SELECT DISTINCT compared_to_category FROM products WHERE compared_to_category IS NOT NULL AND compared_to_category LIKE '%chocolate%' ORDER BY compared_to_category LIMIT 1000"
            }
          ]
        },
        "complete": {
          "type": "INTEGER",
          "description": "Binary flag indicating whether a product entry is complete (1) or incomplete (0). Used to track the completeness status of product information in the database.",
          "examples": [
            0,
            1,
            0
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the distribution of complete vs incomplete products with percentages",
              "sql": "SELECT complete, COUNT(*) as count, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM products WHERE complete IS NOT NULL), 2) as percentage FROM products WHERE complete IS NOT NULL GROUP BY complete ORDER BY complete"
            },
            {
              "description": "Find the most recently created complete products",
              "sql": "SELECT code, created_t, complete FROM products WHERE complete = 1 ORDER BY created_t DESC LIMIT 1000"
            },
            {
              "description": "Compare the number of ingredients between complete and incomplete products",
              "sql": "SELECT complete, AVG(ARRAY_LENGTH(ingredients_tags)) as avg_ingredients, COUNT(*) as product_count FROM products WHERE complete IS NOT NULL AND ingredients_tags IS NOT NULL GROUP BY complete ORDER BY complete"
            }
          ]
        },
        "completeness": {
          "type": "FLOAT",
          "description": "A score between 0 and 1.1 indicating how complete the product information is in the database. Values above 1.0 indicate products exceeding standard completeness requirements. The score appears to be calculated based on the presence and quality of various product attributes.",
          "examples": [
            "1.1",
            "0.8",
            "0.37"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of products across different completeness levels to assess data quality",
              "sql": "SELECT CASE WHEN completeness >= 1.0 THEN 'Complete or Above' WHEN completeness >= 0.8 THEN 'Mostly Complete' WHEN completeness >= 0.5 THEN 'Partially Complete' ELSE 'Minimal Information' END as completeness_category, COUNT(*) as product_count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage FROM products WHERE completeness IS NOT NULL GROUP BY completeness_category ORDER BY MIN(completeness) DESC"
            },
            {
              "description": "Find products with high data quality (completeness >= 0.9) to identify well-documented items",
              "sql": "SELECT code, completeness, product_name, brands FROM products WHERE completeness >= 0.9 ORDER BY completeness DESC LIMIT 1000"
            },
            {
              "description": "Analyze average completeness by brand to identify brands with better data quality",
              "sql": "SELECT brands, COUNT(*) as product_count, ROUND(AVG(completeness), 2) as avg_completeness, MIN(completeness) as min_completeness, MAX(completeness) as max_completeness FROM products WHERE completeness IS NOT NULL AND brands IS NOT NULL GROUP BY brands HAVING COUNT(*) >= 10 ORDER BY avg_completeness DESC LIMIT 1000"
            }
          ]
        },
        "correctors_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags identifying users, bots, and systems that have made corrections or modifications to a product entry. This includes human contributors, automated systems, mobile apps, and data import services.",
          "examples": [
            "['kiliweb', 'yukafix', 'autorotate-bot']",
            "['teolemon', 'roboto-app', 'usda-ndb-import', 'packbot']",
            "['yuka.v2ux4dtbvp1j5vn9', 'openfoodfacts-contributors', 'ecoscore-impact-estimator']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most active correctors and their contribution counts",
              "sql": "SELECT unnest(correctors_tags) as corrector, COUNT(*) as correction_count FROM products WHERE correctors_tags IS NOT NULL GROUP BY corrector ORDER BY correction_count DESC LIMIT 1000;"
            },
            {
              "description": "Find products with extensive corrections (more than 5 correctors)",
              "sql": "SELECT code, array_length(correctors_tags) as number_of_correctors, correctors_tags FROM products WHERE array_length(correctors_tags) > 5 ORDER BY array_length(correctors_tags) DESC LIMIT 1000;"
            },
            {
              "description": "Find products corrected by a specific system (e.g., yukafix)",
              "sql": "SELECT code, correctors_tags, product_name FROM products WHERE correctors_tags IS NOT NULL AND array_contains(correctors_tags, 'yukafix') LIMIT 1000;"
            }
          ]
        },
        "countries_tags": {
          "type": "VARCHAR[]",
          "description": "An array of country tags where the product is available or distributed. Each tag uses a standardized format with language prefix (e.g., 'en:canada'). Can include country-level tags, regional tags (e.g., 'fr:quebec'), and global tags (e.g., 'en:world').",
          "examples": [
            "['en:canada', 'en:france']",
            "['en:canada', 'en:united-states', 'en:world']",
            "['en:australia', 'en:canada', 'en:france', 'en:germany']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of products by country, showing the count of products available in each country",
              "sql": "SELECT unnest(countries_tags) as country, COUNT(*) as product_count FROM products WHERE countries_tags IS NOT NULL GROUP BY country ORDER BY product_count DESC LIMIT 1000;"
            },
            {
              "description": "Find products that are distributed in multiple countries (more than 2)",
              "sql": "SELECT code, product_name, countries_tags FROM products WHERE array_length(countries_tags) > 2 LIMIT 1000;"
            },
            {
              "description": "Find products available in specific countries (e.g., both France and Canada)",
              "sql": "SELECT code, product_name, countries_tags FROM products WHERE array_contains(countries_tags, 'en:france') AND array_contains(countries_tags, 'en:canada') LIMIT 1000;"
            }
          ]
        },
        "created_t": {
          "type": "BIGINT",
          "description": "Unix timestamp (seconds since epoch) representing when the product was created in the database. The values range from 2021 to 2025, with timestamps stored as seconds since January 1, 1970.",
          "examples": [
            "1737535051",
            "1737530176",
            "1737522314"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the count of products created in the last 30 days",
              "sql": "SELECT COUNT(*) as recent_products FROM products WHERE created_t >= CAST(EXTRACT(epoch FROM CURRENT_DATE - INTERVAL '30 days') AS BIGINT)"
            },
            {
              "description": "Get the distribution of products by creation year",
              "sql": "SELECT EXTRACT(year FROM TO_TIMESTAMP(created_t)) as year, COUNT(*) as product_count FROM products WHERE created_t IS NOT NULL GROUP BY year ORDER BY year DESC"
            },
            {
              "description": "Find the 10 most recently added products with their creation dates in human-readable format",
              "sql": "SELECT code, TO_TIMESTAMP(created_t) as creation_date FROM products ORDER BY created_t DESC LIMIT 10"
            }
          ]
        },
        "creator": {
          "type": "VARCHAR",
          "description": "Username or identifier of the Open Food Facts contributor who created or last modified the product entry. This field represents members of the Open Food Facts community who contribute product information to the database. The field has 100% completion rate with no NULL values, suggesting it's a mandatory field in the system.",
          "examples": [
            "kiliweb",
            "macrofactor",
            "openfoodfacts-contributors"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the top 10 most active creators by number of products they've added",
              "sql": "SELECT creator, COUNT(*) as product_count FROM products WHERE creator IS NOT NULL GROUP BY creator ORDER BY product_count DESC LIMIT 10"
            },
            {
              "description": "Get the list of products added by a specific creator",
              "sql": "SELECT code, product_name, creator, created_t FROM products WHERE creator = 'twoflower' ORDER BY created_t DESC LIMIT 1000"
            },
            {
              "description": "Calculate the percentage of products with creator information",
              "sql": "SELECT ROUND(100.0 * COUNT(CASE WHEN creator IS NOT NULL THEN 1 END) / COUNT(*), 2) as percentage_with_creator FROM products"
            }
          ]
        },
        "data_quality_errors_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags indicating data quality validation errors found in the product data. These tags primarily focus on nutritional value inconsistencies, such as energy value mismatches, impossible nutritional totals, and formatting issues.",
          "examples": [
            "['en:energy-value-in-kcal-does-not-match-value-computed-from-other-nutrients']",
            "['en:nutrition-value-total-over-105', 'en:energy-value-in-kcal-does-not-match-value-computed-from-other-nutrients']",
            "['en:serving-size-is-missing-digits']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common data quality errors and their frequency",
              "sql": "SELECT unnest(data_quality_errors_tags) as error_tag, COUNT(*) as frequency FROM products WHERE data_quality_errors_tags IS NOT NULL AND array_length(data_quality_errors_tags) > 0 GROUP BY error_tag ORDER BY frequency DESC LIMIT 1000"
            },
            {
              "description": "Identify products with multiple quality issues (having 3 or more error tags)",
              "sql": "SELECT code, product_name, data_quality_errors_tags, array_length(data_quality_errors_tags) as error_count FROM products WHERE array_length(data_quality_errors_tags) >= 3 ORDER BY array_length(data_quality_errors_tags) DESC LIMIT 1000"
            },
            {
              "description": "Find products with specific quality issues related to energy values",
              "sql": "SELECT code, product_name, data_quality_errors_tags FROM products WHERE array_contains(data_quality_errors_tags, 'en:energy-value-in-kcal-does-not-match-value-computed-from-other-nutrients') LIMIT 1000"
            }
          ]
        },
        "data_quality_info_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags describing various aspects of product data quality, including packaging information completeness, ingredient analysis status, ecoscore computation status, and food group classification levels. Each tag is prefixed with 'en:' and provides specific information about different quality aspects of the product data.",
          "examples": [
            "['en:no-packaging-data', 'en:ingredients-percent-analysis-ok', 'en:ecoscore-extended-data-not-computed', 'en:food-groups-1-unknown']",
            "['en:packaging-data-incomplete', 'en:ingredients-percent-analysis-ok', 'en:all-ingredients-with-specified-percent', 'en:food-groups-2-known']",
            "['en:ecoscore-extended-data-computed', 'en:food-groups-1-known', 'en:food-groups-2-known', 'en:food-groups-3-unknown']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with specific quality issues (missing packaging data and ecoscore not computed)",
              "sql": "SELECT code, product_name, data_quality_info_tags FROM products WHERE array_contains(data_quality_info_tags, 'en:no-packaging-data') AND array_contains(data_quality_info_tags, 'en:ecoscore-extended-data-not-computed') LIMIT 1000;"
            },
            {
              "description": "Find products with complete ingredient percentage documentation",
              "sql": "SELECT code, product_name, data_quality_info_tags FROM products WHERE array_contains(data_quality_info_tags, 'en:ingredients-percent-analysis-ok') LIMIT 1000;"
            },
            {
              "description": "Find products with complete food group classification (known at all levels)",
              "sql": "SELECT code, product_name, data_quality_info_tags FROM products WHERE array_contains(data_quality_info_tags, 'en:food-groups-1-known') AND array_contains(data_quality_info_tags, 'en:food-groups-2-known') AND array_contains(data_quality_info_tags, 'en:food-groups-3-known') LIMIT 1000;"
            }
          ]
        },
        "data_quality_warnings_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized tags indicating potential data quality issues or warnings for a product. These warnings cover various aspects including nutritional data consistency, ingredient documentation completeness, environmental score calculations, and packaging information.",
          "examples": [
            [
              "ecoscore-origins-of-ingredients-origins-are-100-percent-unknown",
              "serving-quantity-defined-but-quantity-undefined"
            ],
            [
              "energy-value-in-kcal-may-not-match-value-computed-from-other-nutrients",
              "ingredients-number-of-languages-above-1"
            ],
            [
              "nutrition-3-or-more-values-are-identical",
              "ecoscore-production-system-no-label"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with the most data quality warnings, which can help identify problematic entries needing review",
              "sql": "SELECT code, array_length(data_quality_warnings_tags, 1) as warning_count, data_quality_warnings_tags FROM products WHERE data_quality_warnings_tags IS NOT NULL ORDER BY array_length(data_quality_warnings_tags, 1) DESC LIMIT 1000;"
            },
            {
              "description": "Get the distribution of most common data quality warnings to understand systematic issues",
              "sql": "SELECT unnest(data_quality_warnings_tags) as warning, COUNT(*) as frequency FROM products WHERE data_quality_warnings_tags IS NOT NULL GROUP BY warning ORDER BY frequency DESC LIMIT 1000;"
            },
            {
              "description": "Find products with specific quality issues, such as unknown ingredient origins",
              "sql": "SELECT code, data_quality_warnings_tags FROM products WHERE array_contains(data_quality_warnings_tags, 'ecoscore-origins-of-ingredients-origins-are-100-percent-unknown') LIMIT 1000;"
            }
          ]
        },
        "data_sources_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags identifying the sources of product data, including mobile applications, databases, and certification labels that contributed information about the product. Common sources include mobile apps (like Yuka, MacroFactor), databases (like USDA), and certification labels (like Non-GMO Project).",
          "examples": [
            "['app-yuka', 'apps']",
            "['app-yuka', 'apps', 'app-smoothie-openfoodfacts']",
            "['app-yuka', 'apps', 'labels', 'label-non-gmo-project']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the most common data sources and their frequency",
              "sql": "SELECT unnest(data_sources_tags) as source, count(*) as frequency FROM products WHERE data_sources_tags IS NOT NULL GROUP BY source ORDER BY frequency DESC LIMIT 1000"
            },
            {
              "description": "Find products with data from multiple sources (3 or more)",
              "sql": "SELECT code, data_sources_tags FROM products WHERE array_length(data_sources_tags) >= 3 ORDER BY array_length(data_sources_tags) DESC LIMIT 1000"
            },
            {
              "description": "Find products that have both app data and certification labels",
              "sql": "SELECT code, data_sources_tags FROM products WHERE array_contains(data_sources_tags, 'labels') AND array_contains(data_sources_tags, 'apps') LIMIT 1000"
            }
          ]
        },
        "ecoscore_grade": {
          "type": "VARCHAR",
          "description": "Environmental impact grade of the product, ranging from 'a-plus' (best) to 'f' (worst). The score can also be 'unknown' or 'not-applicable'. This grade reflects the product's overall environmental impact based on various factors such as production methods, packaging, and transportation.",
          "examples": [
            "a-plus",
            "b",
            "unknown"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the distribution of ecoscore grades to analyze environmental impact coverage",
              "sql": "SELECT ecoscore_grade, COUNT(*) as count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage FROM products WHERE ecoscore_grade IS NOT NULL GROUP BY ecoscore_grade ORDER BY count DESC;"
            },
            {
              "description": "Find products with the best environmental impact (a-plus grade)",
              "sql": "SELECT code, product_name, ecoscore_grade FROM products WHERE ecoscore_grade = 'a-plus' ORDER BY code;"
            },
            {
              "description": "Get distribution of actual grades excluding unknown and not-applicable values",
              "sql": "SELECT ecoscore_grade, COUNT(*) as count FROM products WHERE ecoscore_grade NOT IN ('unknown', 'not-applicable') GROUP BY ecoscore_grade ORDER BY ecoscore_grade;"
            }
          ]
        },
        "ecoscore_data": {
          "type": "VARCHAR",
          "description": "JSON structured data containing detailed environmental impact scoring information for food products. Includes ecoscore grade (A-E), numerical scores, and adjustments based on packaging, production system, origins, and CO2 impact. Also contains missing data indicators and detailed breakdowns of environmental impacts.",
          "examples": [
            "{\"score\": 64, \"grade\": \"b\", \"status\": \"known\", \"agribalyse\": {\"score\": 84}, \"adjustments\": {\"packaging\": {\"score\": -15, \"warning\": \"packaging_data_missing\"}, \"production_system\": {\"score\": 0, \"warning\": \"no_label\"}, \"origins_of_ingredients\": {\"score\": -5, \"value\": 100, \"origin\": \"unknown\"}}}",
            "{\"status\": \"unknown\", \"missing\": {\"labels\": true, \"categories\": true, \"origins\": true, \"packagings\": true}}",
            "{\"score\": 34, \"grade\": \"d\", \"status\": \"known\", \"agribalyse\": {\"score\": 54}, \"adjustments\": {\"packaging\": {\"score\": -15}, \"origins_of_ingredients\": {\"score\": -5}}}"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of ecoscore grades for products with known status",
              "sql": "SELECT JSON_EXTRACT_STRING(TRY_CAST(ecoscore_data AS JSON), '$.grade') as grade, COUNT(*) as count FROM products WHERE ecoscore_data IS NOT NULL AND JSON_EXTRACT_STRING(TRY_CAST(ecoscore_data AS JSON), '$.status') = 'known' GROUP BY grade ORDER BY grade"
            },
            {
              "description": "Find products with high environmental impact scores (A or B grade) and their categories",
              "sql": "SELECT code, product_name, categories_tags, JSON_EXTRACT_STRING(TRY_CAST(ecoscore_data AS JSON), '$.grade') as ecoscore_grade, JSON_EXTRACT_STRING(TRY_CAST(ecoscore_data AS JSON), '$.score') as ecoscore_score FROM products WHERE ecoscore_data IS NOT NULL AND JSON_EXTRACT_STRING(TRY_CAST(ecoscore_data AS JSON), '$.grade') IN ('a', 'b') LIMIT 1000"
            },
            {
              "description": "Analyze missing data patterns in ecoscore calculations",
              "sql": "SELECT COUNT(*) as total_products, COUNT(*) FILTER (WHERE JSON_EXTRACT_STRING(TRY_CAST(ecoscore_data AS JSON), '$.status') = 'unknown') as unknown_status, COUNT(*) FILTER (WHERE JSON_EXTRACT_PATH(TRY_CAST(ecoscore_data AS JSON), 'missing', 'labels')::boolean) as missing_labels, COUNT(*) FILTER (WHERE JSON_EXTRACT_PATH(TRY_CAST(ecoscore_data AS JSON), 'missing', 'origins')::boolean) as missing_origins, COUNT(*) FILTER (WHERE JSON_EXTRACT_PATH(TRY_CAST(ecoscore_data AS JSON), 'missing', 'packagings')::boolean) as missing_packagings FROM products WHERE ecoscore_data IS NOT NULL"
            }
          ]
        },
        "ecoscore_score": {
          "type": "INTEGER",
          "description": "Environmental impact score for products, typically ranging from -100 to 100, with higher scores indicating better environmental impact. The score considers factors like packaging, transportation, and production methods.",
          "examples": [
            -30,
            0,
            100
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with excellent environmental impact (ecoscore >= 80)",
              "sql": "SELECT code, product_name, ecoscore_score FROM products WHERE ecoscore_score >= 80 ORDER BY ecoscore_score DESC LIMIT 1000"
            },
            {
              "description": "Calculate the distribution of products across different ecoscore ranges",
              "sql": "SELECT CASE WHEN ecoscore_score < 0 THEN 'negative' WHEN ecoscore_score < 40 THEN 'low' WHEN ecoscore_score < 70 THEN 'medium' ELSE 'high' END AS score_category, COUNT(*) as product_count FROM products WHERE ecoscore_score IS NOT NULL GROUP BY score_category ORDER BY score_category"
            },
            {
              "description": "Find products with missing ecoscore and their categories to identify gaps in environmental assessment",
              "sql": "SELECT categories, COUNT(*) as products_without_score FROM products WHERE ecoscore_score IS NULL GROUP BY categories ORDER BY products_without_score DESC LIMIT 1000"
            }
          ]
        },
        "ecoscore_tags": {
          "type": "VARCHAR[]",
          "description": "An array containing the ecological score tag for a product. The score ranges from 'a-plus' (best) to 'f' (worst), with special values 'unknown' and 'not-applicable'. While it's an array type, it typically contains only one value representing the product's environmental impact rating.",
          "examples": [
            "['a-plus']",
            "['unknown']",
            "['e']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the distribution of eco-scores across all products to understand the environmental impact of the product catalog",
              "sql": "SELECT ecoscore_tags[1] as ecoscore, COUNT(*) as product_count FROM products WHERE ecoscore_tags IS NOT NULL GROUP BY ecoscore_tags[1] ORDER BY product_count DESC"
            },
            {
              "description": "Find products with the best environmental impact (a-plus rating)",
              "sql": "SELECT code, product_name, ecoscore_tags FROM products WHERE ecoscore_tags = ARRAY['a-plus']"
            },
            {
              "description": "Identify products with poor environmental impact (e or f ratings) for potential improvement",
              "sql": "SELECT code, product_name, ecoscore_tags FROM products WHERE ecoscore_tags[1] IN ('e', 'f')"
            }
          ]
        },
        "emb_codes": {
          "type": "VARCHAR",
          "description": "Manufacturing and certification codes for products, including EMB (European Mixed Batch) codes, FSC certification codes, and other manufacturing identifiers. Can contain multiple codes separated by commas. Most common formats include EMB prefixed codes (e.g., 'EMB 44011B'), FSC certification codes, and numeric identifiers.",
          "examples": [
            "EMB 44011B",
            "FSC-C016043",
            "EMB 85052,EMB 57620A"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with multiple manufacturing codes (indicated by presence of comma)",
              "sql": "SELECT code, emb_codes FROM products WHERE emb_codes LIKE '%,%' ORDER BY code LIMIT 1000"
            },
            {
              "description": "Analyze distribution of different EMB code formats",
              "sql": "SELECT CASE WHEN emb_codes LIKE 'EMB%' THEN 'EMB format' WHEN emb_codes LIKE 'FSC%' THEN 'FSC format' WHEN emb_codes ~ '^[0-9]+$' THEN 'Numeric only' ELSE 'Other format' END as code_pattern, COUNT(*) as pattern_count FROM products WHERE emb_codes IS NOT NULL GROUP BY code_pattern ORDER BY pattern_count DESC"
            },
            {
              "description": "Find products with standard EMB codes and their categories",
              "sql": "SELECT code, emb_codes, categories FROM products WHERE emb_codes LIKE 'EMB%' ORDER BY code LIMIT 1000"
            }
          ]
        },
        "editors": {
          "type": "VARCHAR[]",
          "description": "Array of usernames representing the contributors who have edited the product entry. Can include both human editors and automated bots. Empty strings in the array might represent anonymous contributions.",
          "examples": [
            "['', 'teolemon', 'boudeffa', 'tacite']",
            "['upcbot', 'ggrahamott']",
            "['date-limite-app', 'teolemon']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most active editors by counting their contributions, excluding empty strings",
              "sql": "WITH RECURSIVE unnested AS ( SELECT UNNEST(editors) as editor FROM products WHERE editors IS NOT NULL ) SELECT editor, COUNT(*) as product_count FROM unnested WHERE editor != '' GROUP BY editor ORDER BY product_count DESC LIMIT 1000"
            },
            {
              "description": "Find products that have been reviewed by multiple editors (more than 2)",
              "sql": "SELECT code, editors, array_length(editors) as editor_count FROM products WHERE editors IS NOT NULL AND array_length(editors) > 2 ORDER BY array_length(editors) DESC LIMIT 1000"
            },
            {
              "description": "Find products edited by a specific editor",
              "sql": "SELECT code, editors FROM products WHERE editors IS NOT NULL AND array_contains(editors, 'teolemon') LIMIT 1000"
            }
          ]
        },
        "emb_codes_tags": {
          "type": "VARCHAR[]",
          "description": "Array of EMB (establishment) codes that identify manufacturing or packaging facilities for the product. These codes can include various formats such as FSC (Forest Stewardship Council) certifications, French establishment codes (starting with 'fr-'), and other country-specific manufacturing codes.",
          "examples": [
            "fr-02-617-001-ec",
            "FSC-C014047",
            "emb-21273"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with specific EMB code patterns (e.g., French establishments)",
              "sql": "SELECT code, emb_codes_tags FROM products WHERE array_exists(emb_codes_tags, x -> x LIKE 'fr-%') LIMIT 1000"
            },
            {
              "description": "Get products with multiple EMB codes, ordered by number of codes",
              "sql": "SELECT code, emb_codes_tags, array_length(emb_codes_tags) as num_codes FROM products WHERE emb_codes_tags IS NOT NULL AND array_length(emb_codes_tags) > 1 ORDER BY array_length(emb_codes_tags) DESC LIMIT 1000"
            },
            {
              "description": "Find products with FSC certification codes",
              "sql": "SELECT code, emb_codes_tags FROM products WHERE array_exists(emb_codes_tags, x -> x LIKE 'FSC-%') LIMIT 1000"
            }
          ]
        },
        "entry_dates_tags": {
          "type": "VARCHAR[]",
          "description": "An array containing three date-related strings for when the product was entered into the database. The array follows the pattern: [full_date, year_month, year]. For example: ['2018-08-30', '2018-08', '2018']",
          "examples": [
            "['2015-03-11', '2015-03', '2015']",
            "['2016-09-22', '2016-09', '2016']",
            "['2018-08-30', '2018-08', '2018']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products by entry year using the year component (third element) of the entry_dates_tags array",
              "sql": "SELECT entry_dates_tags[3] as entry_year, COUNT(*) as product_count FROM products WHERE entry_dates_tags IS NOT NULL GROUP BY entry_dates_tags[3] ORDER BY entry_year DESC LIMIT 1000"
            },
            {
              "description": "Find products entered in a specific month (e.g., August 2018) using the year-month component",
              "sql": "SELECT code, entry_dates_tags FROM products WHERE entry_dates_tags IS NOT NULL AND entry_dates_tags[2] = '2018-08' LIMIT 1000"
            },
            {
              "description": "Get the distribution of entries by month for a specific year",
              "sql": "SELECT entry_dates_tags[2] as entry_month, COUNT(*) as product_count FROM products WHERE entry_dates_tags IS NOT NULL AND entry_dates_tags[3] = '2018' GROUP BY entry_dates_tags[2] ORDER BY entry_month LIMIT 1000"
            }
          ]
        },
        "food_groups_tags": {
          "type": "VARCHAR[]",
          "description": "An array of food group tags that categorize products in a hierarchical structure. Each tag typically starts with 'en:' and represents different levels of food categorization, from broad categories (like 'beverages') to specific subcategories (like 'artificially-sweetened-beverages').",
          "examples": [
            "['en:beverages', 'en:artificially-sweetened-beverages']",
            "['en:cereals-and-potatoes', 'en:bread']",
            "['en:fish-meat-eggs', 'en:meat', 'en:poultry']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the distribution of top-level food groups with their product counts",
              "sql": "SELECT food_groups_tags[1] as main_group, COUNT(*) as product_count FROM products WHERE ARRAY_LENGTH(food_groups_tags) > 0 GROUP BY main_group ORDER BY product_count DESC LIMIT 1000"
            },
            {
              "description": "Find products that belong to multiple food group categories (have detailed classification)",
              "sql": "SELECT code, food_groups_tags FROM products WHERE ARRAY_LENGTH(food_groups_tags) > 2 ORDER BY ARRAY_LENGTH(food_groups_tags) DESC LIMIT 1000"
            },
            {
              "description": "Find products in a specific food category and its subcategories",
              "sql": "SELECT code, food_groups_tags FROM products WHERE food_groups_tags[1] = 'en:beverages' AND ARRAY_LENGTH(food_groups_tags) > 1 LIMIT 1000"
            }
          ]
        },
        "generic_name": {
          "type": "STRUCT(lang VARCHAR, text VARCHAR)[]",
          "description": "Generic product name in multiple languages. Contains structured array of language-text pairs, commonly including English and French translations for Canadian market compliance.",
          "examples": [
            "[{'lang': 'en', 'text': 'Soy beverage with vanilla'}, {'lang': 'fr', 'text': 'Boisson de soja à la vanille'}]",
            "[{'lang': 'fr', 'text': 'Guimauves Super Moelleuses'}, {'lang': 'en', 'text': 'Super Soft Marshmallows'}]",
            "[{'lang': 'en', 'text': 'Chickpeas, hummus'}, {'lang': 'fr', 'text': 'Pois chiches, houmous'}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get products with their generic name in English, falling back to main language if English is not available",
              "sql": "SELECT code, COALESCE( UNNEST(LIST_FILTER(generic_name, x -> x.lang = 'en'))[text], UNNEST(LIST_FILTER(generic_name, x -> x.lang = 'main'))[text] ) AS generic_name_en FROM products WHERE generic_name IS NOT NULL AND ARRAY_LENGTH(generic_name) > 0 LIMIT 1000;"
            },
            {
              "description": "Find products with their generic names in multiple languages (more than one language version)",
              "sql": "SELECT code, generic_name FROM products WHERE generic_name IS NOT NULL AND ARRAY_LENGTH(generic_name) > 1 LIMIT 1000;"
            },
            {
              "description": "Find products where generic name contains specific text in any language",
              "sql": "SELECT code, generic_name FROM products WHERE generic_name IS NOT NULL AND EXISTS ( SELECT 1 FROM UNNEST(generic_name) AS t WHERE LOWER(t.text) LIKE '%chocolate%' ) LIMIT 1000;"
            }
          ]
        },
        "images": {
          "type": "STRUCT(key VARCHAR, imgid INTEGER, sizes STRUCT(100 STRUCT(h INTEGER, w INTEGER), 200 STRUCT(h INTEGER, w INTEGER), 400 STRUCT(h INTEGER, w INTEGER)))[]",
          "description": "Array of image metadata structs containing image identifiers, IDs, and size variants. Each image entry includes a key (e.g., 'front_en', 'nutrition_fr'), an optional image ID, and size information for different dimensions (100px, 200px, 400px) including height and width.",
          "examples": [
            {
              "key": "front_en",
              "imgid": 1234,
              "sizes": {
                "100": {
                  "h": 100,
                  "w": 75
                },
                "200": {
                  "h": 200,
                  "w": 150
                },
                "400": {
                  "h": 400,
                  "w": 300
                }
              }
            },
            {
              "key": "nutrition_fr",
              "imgid": 5678,
              "sizes": {
                "100": {
                  "h": 100,
                  "w": 100
                },
                "200": {
                  "h": 200,
                  "w": 200
                }
              }
            },
            {
              "key": "1",
              "imgid": null,
              "sizes": {
                "100": {
                  "h": 100,
                  "w": 133
                }
              }
            }
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products with and without images",
              "sql": "SELECT COUNT(*) FILTER (WHERE images IS NOT NULL) as with_images, COUNT(*) FILTER (WHERE images IS NULL) as without_images FROM products"
            },
            {
              "description": "Get products with their front image metadata",
              "sql": "SELECT code, images FROM products WHERE images IS NOT NULL AND ARRAY_CONTAINS(images::json, 'front_en') LIMIT 1000"
            },
            {
              "description": "Find products with complete image sets (front, ingredients, and nutrition)",
              "sql": "SELECT code, images FROM products WHERE images IS NOT NULL AND ARRAY_CONTAINS(images::json, 'front_en') AND ARRAY_CONTAINS(images::json, 'ingredients_en') AND ARRAY_CONTAINS(images::json, 'nutrition_en') LIMIT 1000"
            }
          ]
        },
        "informers_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags identifying the sources or contributors who provided or modified information about the product. These can include individual contributors, automated systems, apps (like Yuka), and data import bots.",
          "examples": [
            "['openfoodfacts-contributors', 'inf']",
            "['yuka.V3ZGZFM3VTd2UE1RcHRnSDJ6LzV5dU52bHJLeFIybnNFdU5MSVE9PQ', 'kiliweb', 'roboto-app']",
            "['openfoodfacts-contributors', 'fix-missing-lang-bot', 'teolemon', 'org-database-usda']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most active contributors by counting their contributions",
              "sql": "SELECT unnest(informers_tags) as informer, COUNT(*) as contribution_count FROM products WHERE informers_tags IS NOT NULL GROUP BY informer ORDER BY contribution_count DESC LIMIT 1000"
            },
            {
              "description": "Find products with multiple sources of information (more than 3 contributors)",
              "sql": "SELECT code, array_length(informers_tags) as number_of_informers, informers_tags FROM products WHERE array_length(informers_tags) > 3 ORDER BY array_length(informers_tags) DESC LIMIT 1000"
            },
            {
              "description": "Find products that have both community contributions and robot verification",
              "sql": "SELECT code, informers_tags FROM products WHERE array_contains(informers_tags, 'openfoodfacts-contributors') AND array_contains(informers_tags, 'roboto-app') LIMIT 1000"
            }
          ]
        },
        "ingredients_analysis_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized tags analyzing product ingredients across three main dimensions: palm oil content, vegan status, and vegetarian status. Tags are prefixed with 'en:' and include certainty levels (e.g., 'unknown', 'maybe', confirmed status).",
          "examples": [
            "['en:palm-oil-free', 'en:vegan', 'en:vegetarian']",
            "['en:palm-oil', 'en:non-vegan', 'en:non-vegetarian']",
            "['en:palm-oil-content-unknown', 'en:vegan-status-unknown', 'en:vegetarian-status-unknown']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products by palm oil status to understand distribution",
              "sql": "SELECT UNNEST(ingredients_analysis_tags) as analysis_tag, COUNT(*) as product_count FROM products WHERE ingredients_analysis_tags IS NOT NULL AND analysis_tag LIKE '%palm%' GROUP BY analysis_tag"
            },
            {
              "description": "Find all confirmed vegan products",
              "sql": "SELECT code, product_name, ingredients_analysis_tags FROM products WHERE ingredients_analysis_tags IS NOT NULL AND array_contains(ingredients_analysis_tags, 'en:vegan')"
            },
            {
              "description": "Find products with incomplete ingredient analysis",
              "sql": "SELECT code, product_name, ingredients_analysis_tags FROM products WHERE ingredients_analysis_tags IS NOT NULL AND ( array_contains(ingredients_analysis_tags, 'en:vegan-status-unknown') OR array_contains(ingredients_analysis_tags, 'en:palm-oil-content-unknown') )"
            }
          ]
        },
        "ingredients_from_palm_oil_n": {
          "type": "INTEGER",
          "description": "Counts the number of ingredients derived from palm oil in a product. Values range from 0 (no palm oil ingredients) to 2 (two palm oil ingredients). This field is important for environmental and dietary analysis, as palm oil production has significant environmental impacts.",
          "examples": [
            0,
            1,
            2
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products containing palm oil ingredients (at least 1), ordered by the number of palm oil ingredients",
              "sql": "SELECT code, product_name, ingredients_from_palm_oil_n FROM products WHERE ingredients_from_palm_oil_n > 0 ORDER BY ingredients_from_palm_oil_n DESC LIMIT 1000"
            },
            {
              "description": "Calculate the distribution of palm oil ingredients across products where this information is available",
              "sql": "SELECT ingredients_from_palm_oil_n, COUNT(*) as product_count FROM products WHERE ingredients_from_palm_oil_n IS NOT NULL GROUP BY ingredients_from_palm_oil_n ORDER BY ingredients_from_palm_oil_n"
            },
            {
              "description": "Find products with complete palm oil information (not null) and categorize them by palm oil content",
              "sql": "SELECT CASE ingredients_from_palm_oil_n WHEN 0 THEN 'No Palm Oil' WHEN 1 THEN 'One Palm Oil Ingredient' WHEN 2 THEN 'Two Palm Oil Ingredients' END as category, COUNT(*) as count FROM products WHERE ingredients_from_palm_oil_n IS NOT NULL GROUP BY ingredients_from_palm_oil_n ORDER BY ingredients_from_palm_oil_n"
            }
          ]
        },
        "ingredients": {
          "type": "VARCHAR",
          "description": "JSON array containing detailed information about product ingredients. Each ingredient is stored as a JSON object containing properties such as ingredient name (text), percentage information (percent_min, percent_max, percent_estimate), taxonomy identification (id, is_in_taxonomy), ingredient rank, and dietary information (vegan status).",
          "examples": [
            {
              "text": "whole grain wheat flour",
              "percent_min": 60,
              "percent_max": 100,
              "percent_estimate": 80,
              "id": "en:whole-grain-wheat-flour",
              "rank": 1,
              "is_in_taxonomy": true
            },
            {
              "text": "milk",
              "percent_estimate": 95,
              "id": "en:milk",
              "rank": 1,
              "is_in_taxonomy": true,
              "vegan": "no"
            },
            {
              "text": "sugar",
              "percent_estimate": 30,
              "id": "en:sugar",
              "rank": 2,
              "is_in_taxonomy": true
            }
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products containing a specific ingredient (e.g., milk) using text search",
              "sql": "SELECT code, ingredients FROM products WHERE ingredients IS NOT NULL AND ingredients LIKE '%\"text\":\"milk\"%' LIMIT 1000"
            },
            {
              "description": "List products sorted by number of ingredients",
              "sql": "WITH ingredient_counts AS (SELECT code, (LENGTH(ingredients) - LENGTH(REPLACE(ingredients, '{\"text\":', ''))) / LENGTH('{\"text\":') as ingredient_count FROM products WHERE ingredients IS NOT NULL) SELECT code, ingredient_count FROM ingredient_counts ORDER BY ingredient_count DESC LIMIT 1000"
            },
            {
              "description": "Find products with high percentage of main ingredient (over 90%)",
              "sql": "SELECT code, ingredients FROM products WHERE ingredients IS NOT NULL AND ingredients LIKE '%\"percent_estimate\":9%' AND ingredients LIKE '%\"rank\":1%' LIMIT 1000"
            }
          ]
        },
        "ingredients_n": {
          "type": "INTEGER",
          "description": "Number of ingredients in a product. Represents the total count of distinct ingredients used in the product's composition. Values range from 0 to 289, with an average of about 17 ingredients per product.",
          "examples": [
            1,
            4,
            17
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with ingredient counts above the 90th percentile (complex products)",
              "sql": "WITH stats AS ( SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY ingredients_n) as p90 FROM products WHERE ingredients_n IS NOT NULL ) SELECT code, product_name, ingredients_n FROM products, stats WHERE ingredients_n > stats.p90 ORDER BY ingredients_n DESC LIMIT 1000"
            },
            {
              "description": "Get distribution of products by ingredient count ranges",
              "sql": "SELECT CASE WHEN ingredients_n BETWEEN 0 AND 5 THEN '0-5' WHEN ingredients_n BETWEEN 6 AND 10 THEN '6-10' WHEN ingredients_n BETWEEN 11 AND 20 THEN '11-20' ELSE '21+' END as ingredient_range, COUNT(*) as product_count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage FROM products WHERE ingredients_n IS NOT NULL GROUP BY 1 ORDER BY MIN(ingredients_n)"
            },
            {
              "description": "Find products with abnormally high or low ingredient counts (potential data quality issues)",
              "sql": "WITH stats AS ( SELECT AVG(ingredients_n) as avg_ingredients, STDDEV(ingredients_n) as stddev_ingredients FROM products WHERE ingredients_n IS NOT NULL ) SELECT code, product_name, ingredients_n FROM products, stats WHERE ingredients_n IS NOT NULL AND (ingredients_n = 0 OR ingredients_n > avg_ingredients + 2 * stddev_ingredients) ORDER BY ingredients_n DESC LIMIT 1000"
            }
          ]
        },
        "ingredients_percent_analysis": {
          "type": "INTEGER",
          "description": "A flag indicating the status of ingredients percentage analysis. Value 1 indicates successful parsing of ingredients percentages, -1 indicates failed parsing, and NULL indicates no analysis was performed.",
          "examples": [
            1,
            -1,
            null
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of ingredients percentage analysis status",
              "sql": "SELECT ingredients_percent_analysis, COUNT(*) as count, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM products), 2) as percentage FROM products GROUP BY ingredients_percent_analysis ORDER BY ingredients_percent_analysis"
            },
            {
              "description": "Find products with successful ingredients percentage analysis and their ingredients",
              "sql": "SELECT code, ingredients_text FROM products WHERE ingredients_percent_analysis = 1 LIMIT 1000"
            },
            {
              "description": "Compare products with failed vs successful ingredients percentage analysis by product category",
              "sql": "SELECT categories_tags[1] as main_category, ingredients_percent_analysis, COUNT(*) as count FROM products WHERE ingredients_percent_analysis IS NOT NULL GROUP BY categories_tags[1], ingredients_percent_analysis ORDER BY main_category, ingredients_percent_analysis LIMIT 1000"
            }
          ]
        },
        "ingredients_original_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized ingredient tags, typically prefixed with language codes (e.g., 'en:', 'fr:'). Each tag represents a single ingredient in its normalized form, making it easier to search and analyze product compositions. The tags follow the Open Food Facts taxonomy.",
          "examples": [
            "['en:water', 'en:sugar', 'en:carbon-dioxide']",
            "['en:fortified-wheat-flour', 'en:sugar', 'en:vegetable-oil', 'en:salt']",
            "['en:milk-chocolate', 'en:sugar', 'en:cocoa-butter', 'en:cocoa-paste', 'en:milk-powder']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common ingredients in products and their frequency of use",
              "sql": "SELECT unnest(ingredients_original_tags) as ingredient, COUNT(*) as frequency FROM products WHERE ingredients_original_tags IS NOT NULL GROUP BY ingredient ORDER BY frequency DESC LIMIT 1000;"
            },
            {
              "description": "Find all products containing a specific ingredient (e.g., sugar)",
              "sql": "SELECT code, product_name, ingredients_original_tags FROM products WHERE array_contains(ingredients_original_tags, 'en:sugar') LIMIT 1000;"
            },
            {
              "description": "Find products with the most ingredients, sorted by ingredient count",
              "sql": "SELECT code, product_name, array_length(ingredients_original_tags) as ingredient_count, ingredients_original_tags FROM products WHERE ingredients_original_tags IS NOT NULL ORDER BY array_length(ingredients_original_tags) DESC LIMIT 1000;"
            }
          ]
        },
        "ingredients_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized ingredient tags in English, using the Open Food Facts taxonomy. Each tag is prefixed with 'en:' and represents either a specific ingredient or a category. The tags are hierarchically organized, meaning an ingredient may be tagged both specifically (e.g., 'en:wheat-flour') and categorically (e.g., 'en:cereal').",
          "examples": [
            "['en:blue-agave-syrup']",
            "['en:water', 'en:sugar', 'en:salt']",
            "['en:fortified-wheat-flour', 'en:cereal', 'en:wheat']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common ingredients in products",
              "sql": "SELECT unnest(ingredients_tags) as ingredient, COUNT(*) as count FROM products WHERE ingredients_tags IS NOT NULL GROUP BY ingredient ORDER BY count DESC LIMIT 1000"
            },
            {
              "description": "Find products containing a specific ingredient (e.g., water)",
              "sql": "SELECT code, product_name, ingredients_tags FROM products WHERE ingredients_tags IS NOT NULL AND array_contains(ingredients_tags, 'en:water') LIMIT 1000"
            },
            {
              "description": "Find products by number of ingredients, ordered by complexity",
              "sql": "SELECT code, product_name, array_length(ingredients_tags) as ingredient_count FROM products WHERE ingredients_tags IS NOT NULL ORDER BY ingredient_count DESC LIMIT 1000"
            }
          ]
        },
        "ingredients_with_specified_percent_n": {
          "type": "INTEGER",
          "description": "Counts the number of ingredients in a product that have their percentage explicitly specified. This helps track transparency in ingredient labeling, ranging from 0 to 15.",
          "examples": [
            0,
            1,
            3
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with the most detailed ingredient percentage information (top 1000 products with highest number of specified percentages)",
              "sql": "SELECT code, product_name, ingredients_with_specified_percent_n FROM products WHERE ingredients_with_specified_percent_n > 0 ORDER BY ingredients_with_specified_percent_n DESC LIMIT 1000"
            },
            {
              "description": "Get the distribution of products based on number of ingredients with specified percentages",
              "sql": "SELECT ingredients_with_specified_percent_n, COUNT(*) as product_count FROM products WHERE ingredients_with_specified_percent_n IS NOT NULL GROUP BY ingredients_with_specified_percent_n ORDER BY ingredients_with_specified_percent_n"
            },
            {
              "description": "Calculate the percentage of products that have at least one ingredient with specified percentage",
              "sql": "SELECT ROUND(COUNT(CASE WHEN ingredients_with_specified_percent_n > 0 THEN 1 END) * 100.0 / COUNT(*), 2) as percentage_with_specs FROM products WHERE ingredients_with_specified_percent_n IS NOT NULL"
            }
          ]
        },
        "ingredients_text": {
          "type": "STRUCT(lang VARCHAR, text VARCHAR)[]",
          "description": "Multi-language ingredient lists for products. Each entry in the array contains a language identifier and the corresponding ingredients text in that language. Common languages include 'en' (English), 'fr' (French), and 'main' (primary language).",
          "examples": [
            "[{'lang': 'en', 'text': 'Pure organic maple syrup'}, {'lang': 'main', 'text': 'Pure organic maple syrup'}]",
            "[{'lang': 'en', 'text': 'water, sugar, propylene glycol caramel color, ethyl vanillin, artificial flavor'}]",
            "[{'lang': 'en', 'text': 'lowfat milk, vitamin A palmitate, vitamin D3'}, {'lang': 'fr', 'text': 'lait faible en gras, palmitate de vitamine A, vitamine D3'}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get product ingredients in English, falling back to main language if English is not available",
              "sql": "SELECT code, COALESCE( UNNEST(LIST_FILTER(ingredients_text, x -> x.lang = 'en'))['text'], UNNEST(LIST_FILTER(ingredients_text, x -> x.lang = 'main'))['text'] ) AS ingredients FROM products WHERE ingredients_text IS NOT NULL LIMIT 1000;"
            },
            {
              "description": "Get products with ingredients in both English and French",
              "sql": "SELECT code, UNNEST(LIST_FILTER(ingredients_text, x -> x.lang = 'en'))['text'] as en_ingredients, UNNEST(LIST_FILTER(ingredients_text, x -> x.lang = 'fr'))['text'] as fr_ingredients FROM products WHERE ingredients_text IS NOT NULL AND EXISTS ( SELECT 1 FROM UNNEST(ingredients_text) t WHERE t.lang = 'en' ) AND EXISTS ( SELECT 1 FROM UNNEST(ingredients_text) t WHERE t.lang = 'fr' ) LIMIT 1000;"
            },
            {
              "description": "Count number of products with missing ingredients text",
              "sql": "SELECT COUNT(*) as total_products, COUNT(CASE WHEN ingredients_text IS NULL THEN 1 END) as missing_ingredients, ROUND(COUNT(CASE WHEN ingredients_text IS NULL THEN 1 END) * 100.0 / COUNT(*), 2) as missing_percentage FROM products;"
            }
          ]
        },
        "ingredients_with_unspecified_percent_n": {
          "type": "INTEGER",
          "description": "Counts the number of ingredients in a product that don't have their percentages specified. This metric is important for assessing product transparency and data completeness in ingredient listings.",
          "examples": [
            5,
            44,
            271
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with the highest number of unspecified ingredient percentages, which might need attention for transparency improvement",
              "sql": "SELECT code, product_name, ingredients_with_unspecified_percent_n FROM products WHERE ingredients_with_unspecified_percent_n > 50 ORDER BY ingredients_with_unspecified_percent_n DESC LIMIT 1000;"
            },
            {
              "description": "Analyze the distribution of products based on their number of unspecified ingredients to understand overall transparency levels",
              "sql": "SELECT CASE WHEN ingredients_with_unspecified_percent_n <= 10 THEN '1-10' WHEN ingredients_with_unspecified_percent_n <= 20 THEN '11-20' WHEN ingredients_with_unspecified_percent_n <= 30 THEN '21-30' ELSE 'Over 30' END as range, COUNT(*) as count FROM products WHERE ingredients_with_unspecified_percent_n IS NOT NULL GROUP BY 1 ORDER BY 1;"
            },
            {
              "description": "Identify products where all ingredients lack percentage specifications, calculated as a ratio of unspecified to total ingredients",
              "sql": "SELECT code, product_name, ingredients_with_unspecified_percent_n, ingredients_n, ROUND(CAST(ingredients_with_unspecified_percent_n AS FLOAT) / NULLIF(ingredients_n, 0) * 100, 2) as unspecified_percentage FROM products WHERE ingredients_with_unspecified_percent_n > 0 AND ingredients_n > 0 ORDER BY unspecified_percentage DESC LIMIT 1000;"
            }
          ]
        },
        "ingredients_without_ciqual_codes_n": {
          "type": "INTEGER",
          "description": "Count of ingredients in the product that do not have associated CIQUAL codes. CIQUAL codes are standardized references used in food composition databases. This metric indicates how many ingredients in a product lack standardized classification.",
          "examples": [
            0,
            1,
            136
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of products by number of ingredients without CIQUAL codes",
              "sql": "SELECT ingredients_without_ciqual_codes_n, COUNT(*) as product_count FROM products WHERE ingredients_without_ciqual_codes_n IS NOT NULL GROUP BY ingredients_without_ciqual_codes_n ORDER BY ingredients_without_ciqual_codes_n"
            },
            {
              "description": "Find products with unusually high number of uncoded ingredients (more than 50)",
              "sql": "SELECT code, product_name, ingredients_without_ciqual_codes_n FROM products WHERE ingredients_without_ciqual_codes_n > 50 ORDER BY ingredients_without_ciqual_codes_n DESC"
            },
            {
              "description": "Calculate data completeness statistics for this field",
              "sql": "SELECT COUNT(*) as total_products, COUNT(ingredients_without_ciqual_codes_n) as products_with_data, ROUND(COUNT(ingredients_without_ciqual_codes_n) * 100.0 / COUNT(*), 2) as completion_rate FROM products"
            }
          ]
        },
        "ingredients_without_ciqual_codes": {
          "type": "VARCHAR[]",
          "description": "An array of ingredients that don't have corresponding CIQUAL (French food composition database) codes. These ingredients are typically additives, processing aids, or specific ingredients that cannot be mapped to standard nutritional data. Each ingredient is prefixed with a language code (e.g., 'en:', 'fr:').",
          "examples": [
            "['en:e300', 'en:vegetable-pigment', 'en:vitamin-c']",
            "['en:e202', 'en:e330']",
            "['en:colour', 'en:e341i', 'en:e500ii', 'en:wheat-gluten']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with the highest number of ingredients without CIQUAL codes",
              "sql": "SELECT code, ingredients_without_ciqual_codes, array_length(ingredients_without_ciqual_codes) as ingredient_count FROM products WHERE ingredients_without_ciqual_codes IS NOT NULL ORDER BY array_length(ingredients_without_ciqual_codes) DESC LIMIT 50"
            },
            {
              "description": "Find products containing a specific additive (e.g., E300 - Vitamin C)",
              "sql": "SELECT code, ingredients_without_ciqual_codes FROM products WHERE ingredients_without_ciqual_codes IS NOT NULL AND array_contains(ingredients_without_ciqual_codes, 'en:e300') LIMIT 50"
            },
            {
              "description": "Count products with and without CIQUAL-mapped ingredients",
              "sql": "SELECT COUNT(CASE WHEN ingredients_without_ciqual_codes IS NOT NULL THEN 1 END) as with_non_ciqual, COUNT(CASE WHEN ingredients_without_ciqual_codes IS NULL THEN 1 END) as without_non_ciqual FROM products LIMIT 50"
            }
          ]
        },
        "known_ingredients_n": {
          "type": "INTEGER",
          "description": "Number of recognized ingredients in a product that match the Open Food Facts ingredients taxonomy. A value of 0 indicates no recognized ingredients, while higher values indicate more complex products with more identified ingredients.",
          "examples": [
            "3",
            "9",
            "112"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find distribution of products by number of known ingredients",
              "sql": "SELECT known_ingredients_n, COUNT(*) as product_count FROM products WHERE known_ingredients_n IS NOT NULL GROUP BY known_ingredients_n ORDER BY known_ingredients_n LIMIT 50"
            },
            {
              "description": "Find products with unusually high number of ingredients (complex products)",
              "sql": "SELECT code, product_name, known_ingredients_n FROM products WHERE known_ingredients_n > 50 ORDER BY known_ingredients_n DESC LIMIT 50"
            },
            {
              "description": "Calculate average and median number of ingredients across products",
              "sql": "SELECT AVG(known_ingredients_n) as avg_ingredients, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY known_ingredients_n) as median_ingredients FROM products WHERE known_ingredients_n IS NOT NULL LIMIT 50"
            }
          ]
        },
        "labels": {
          "type": "VARCHAR",
          "description": "A comma-separated list of product labels, certifications, and characteristics. Includes various food claims such as organic certification, dietary restrictions (gluten-free, vegan), and product certifications (Non-GMO, Kosher). Labels can appear in multiple languages (English, French) and may include standardized certifications.",
          "examples": [
            "No artificial flavors, No colorings",
            "Organic, Kosher, Canada Organic, COR Kosher",
            "Végétarien, Sans OGM, Végétalien, en:Non GMO project"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common product labels and their frequency",
              "sql": "WITH split_labels AS ( SELECT unnest(string_split(labels, ',')) as label FROM products WHERE labels IS NOT NULL ) SELECT trim(label) as label, COUNT(*) as count FROM split_labels GROUP BY label ORDER BY count DESC LIMIT 50"
            },
            {
              "description": "Find products with specific certifications (e.g., organic and non-GMO)",
              "sql": "SELECT code, product_name, labels FROM products WHERE labels ILIKE '%organic%' AND labels ILIKE '%non gmo%' LIMIT 50"
            },
            {
              "description": "Count products by number of labels they have",
              "sql": "SELECT array_length(string_split(labels, ',')) as label_count, COUNT(*) as product_count FROM products WHERE labels IS NOT NULL GROUP BY label_count ORDER BY label_count LIMIT 50"
            }
          ]
        },
        "labels_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized tags describing product characteristics and certifications such as 'organic', 'gluten-free', 'kosher', etc. Tags are typically prefixed with language codes like 'en:' for English or 'fr:' for French.",
          "examples": [
            "['en:no-artificial-flavors', 'en:no-colorings']",
            "['en:low-or-no-fat', 'en:low-fat', 'en:source-of-proteins', 'en:high-proteins', 'en:no-trans-fat']",
            "['en:vegetarian', 'en:no-gmos', 'en:vegan', 'en:no-peanuts', 'en:non-gmo-project']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with organic certification",
              "sql": "SELECT code, product_name, labels_tags FROM products WHERE labels_tags IS NOT NULL AND list_contains(labels_tags, 'en:organic') LIMIT 50"
            },
            {
              "description": "Find products with multiple dietary certifications (kosher and gluten-free)",
              "sql": "SELECT code, product_name, labels_tags FROM products WHERE labels_tags IS NOT NULL AND list_contains(labels_tags, 'en:kosher') AND list_contains(labels_tags, 'en:no-gluten') LIMIT 50"
            },
            {
              "description": "Count products by number of labels they have",
              "sql": "SELECT array_length(labels_tags) as label_count, COUNT(*) as product_count FROM products WHERE labels_tags IS NOT NULL GROUP BY label_count ORDER BY label_count LIMIT 50"
            }
          ]
        },
        "lang": {
          "type": "VARCHAR",
          "description": "ISO language code indicating the language of the product information. Most common values are 'fr' (French) and 'en' (English), representing the primary language of product data entry.",
          "examples": [
            "fr",
            "en",
            "it"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of products by language",
              "sql": "SELECT lang, COUNT(*) as count FROM products GROUP BY lang ORDER BY count DESC LIMIT 50"
            },
            {
              "description": "Find products in specific languages (French or English)",
              "sql": "SELECT code, product_name, lang FROM products WHERE lang IN ('fr', 'en') LIMIT 50"
            },
            {
              "description": "Get percentage distribution of main languages",
              "sql": "SELECT lang, COUNT(*) * 100.0 / (SELECT COUNT(*) FROM products) as percentage FROM products GROUP BY lang HAVING COUNT(*) > 100 ORDER BY percentage DESC LIMIT 50"
            }
          ]
        },
        "languages_tags": {
          "type": "VARCHAR[]",
          "description": "An array of language tags indicating the languages present in the product's data. Each tag is prefixed with 'en:'. The array includes language codes (e.g., 'en:french'), a count of languages (e.g., 'en:3'), and 'en:multilingual' flag for products with multiple languages.",
          "examples": [
            "['en:english', 'en:french', 'en:3', 'en:multilingual']",
            "['en:italian', 'en:1']",
            "['en:arabic', 'en:chinese', 'en:english', 'en:french', 'en:4', 'en:multilingual']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with specific language combinations (English and French)",
              "sql": "SELECT code, product_name, languages_tags FROM products WHERE array_contains(languages_tags, 'en:english') AND array_contains(languages_tags, 'en:french') LIMIT 50"
            },
            {
              "description": "Get distribution of number of languages per product",
              "sql": "SELECT UNNEST(languages_tags) as lang_count, COUNT(*) as products FROM products WHERE languages_tags IS NOT NULL AND list_contains(languages_tags, x -> x LIKE 'en:[0-9]') GROUP BY lang_count HAVING lang_count LIKE 'en:%' AND lang_count ~ '^en:[0-9]+$' ORDER BY lang_count LIMIT 50"
            },
            {
              "description": "Find products with rare languages (single language products excluding common languages)",
              "sql": "SELECT code, product_name, languages_tags FROM products WHERE array_length(languages_tags) = 2 AND NOT array_contains(languages_tags, 'en:english') AND NOT array_contains(languages_tags, 'en:french') AND array_contains(languages_tags, 'en:1') LIMIT 50"
            }
          ]
        },
        "last_edit_dates_tags": {
          "type": "VARCHAR[]",
          "description": "An array of date strings representing the last edit date of a product at different granularities (day, month, year). The array contains three elements: [0] full date (YYYY-MM-DD), [1] year-month (YYYY-MM), and [2] year (YYYY).",
          "examples": [
            "['2024-11-13', '2024-11', '2024']",
            "['2023-05-31', '2023-05', '2023']",
            "['2022-08-08', '2022-08', '2022']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with most recent edits",
              "sql": "SELECT code, last_edit_dates_tags[1] as last_edit_date FROM products WHERE last_edit_dates_tags IS NOT NULL ORDER BY last_edit_dates_tags[1] DESC LIMIT 50"
            },
            {
              "description": "Count products edited by year",
              "sql": "SELECT last_edit_dates_tags[3] as edit_year, COUNT(*) as products_count FROM products WHERE last_edit_dates_tags IS NOT NULL GROUP BY last_edit_dates_tags[3] ORDER BY edit_year DESC LIMIT 50"
            },
            {
              "description": "Find products edited in a specific time period",
              "sql": "SELECT code, product_name, last_edit_dates_tags FROM products WHERE last_edit_dates_tags IS NOT NULL AND last_edit_dates_tags[1] LIKE '2024%' LIMIT 50"
            }
          ]
        },
        "last_editor": {
          "type": "VARCHAR",
          "description": "Username or identifier of the last user who edited the product entry. Can be a registered username, automated bot (like 'kiliweb', 'roboto-app'), or anonymous identifier.",
          "examples": [
            "kiliweb",
            "macrofactor",
            "anonymous-s7co2zv64u"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find top contributors by number of products edited",
              "sql": "SELECT last_editor, COUNT(*) as edit_count FROM products WHERE last_editor IS NOT NULL GROUP BY last_editor ORDER BY edit_count DESC LIMIT 50"
            },
            {
              "description": "Get products edited by a specific user",
              "sql": "SELECT code, product_name, created_t FROM products WHERE last_editor = 'kiliweb' ORDER BY created_t DESC LIMIT 50"
            },
            {
              "description": "Find products with no editor information",
              "sql": "SELECT code, product_name FROM products WHERE last_editor IS NULL LIMIT 50"
            }
          ]
        },
        "last_modified_by": {
          "type": "VARCHAR",
          "description": "Username or identifier of the last user or system that modified the product entry in the Open Food Facts database. Can be a registered username, anonymous identifier, or automated system (bot) name.",
          "examples": [
            "kiliweb",
            "anonymous-s7co2zv64u",
            "teolemon"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the top contributors by number of products modified",
              "sql": "SELECT last_modified_by, COUNT(*) as products_modified FROM products WHERE last_modified_by IS NOT NULL GROUP BY last_modified_by ORDER BY products_modified DESC LIMIT 50"
            },
            {
              "description": "Find products modified by automated systems (bots)",
              "sql": "SELECT code, product_name, last_modified_by FROM products WHERE last_modified_by IN ('kiliweb', 'roboto-app', 'packbot', 'beeapi') LIMIT 50"
            },
            {
              "description": "Find products modified by anonymous users",
              "sql": "SELECT code, product_name, last_modified_by FROM products WHERE last_modified_by LIKE 'anonymous-%' LIMIT 50"
            }
          ]
        },
        "last_modified_t": {
          "type": "BIGINT",
          "description": "Unix timestamp indicating when the product was last modified in the database",
          "examples": [
            "1737535051",
            "1737530184",
            "1425250418"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most recently modified products with their last modified timestamps",
              "sql": "SELECT code, product_name, last_modified_t FROM products WHERE last_modified_t IS NOT NULL ORDER BY last_modified_t DESC LIMIT 50"
            },
            {
              "description": "Find products modified in the last month",
              "sql": "SELECT code, product_name, last_modified_t FROM products WHERE last_modified_t > EXTRACT(epoch FROM CURRENT_DATE - INTERVAL '1 month') ORDER BY last_modified_t DESC LIMIT 50"
            },
            {
              "description": "Get product update frequency statistics",
              "sql": "SELECT COUNT(*) as product_count, MIN(last_modified_t) as oldest_update, MAX(last_modified_t) as newest_update, COUNT(DISTINCT last_modified_t) as unique_update_times FROM products WHERE last_modified_t IS NOT NULL LIMIT 50"
            }
          ]
        },
        "last_updated_t": {
          "type": "BIGINT",
          "description": "Unix timestamp indicating when a product was last updated in the database. Represents seconds since epoch (January 1, 1970).",
          "examples": [
            "1737539187",
            "1708531676",
            "1707490480"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the most recently updated products with their creation times",
              "sql": "SELECT code, last_updated_t, created_t FROM products WHERE last_updated_t IS NOT NULL ORDER BY last_updated_t DESC LIMIT 50"
            },
            {
              "description": "Find products that haven't been modified since their creation (last_updated_t equals created_t)",
              "sql": "SELECT code, created_t, last_updated_t FROM products WHERE last_updated_t = created_t LIMIT 50"
            },
            {
              "description": "Get update frequency statistics including oldest and newest updates",
              "sql": "SELECT COUNT(*) as product_count, MIN(last_updated_t) as oldest_update, MAX(last_updated_t) as newest_update, COUNT(DISTINCT last_updated_t) as unique_update_times FROM products WHERE last_updated_t IS NOT NULL LIMIT 50"
            }
          ]
        },
        "link": {
          "type": "VARCHAR",
          "description": "URL linking to the manufacturer's official product webpage or product information page",
          "examples": [
            "https://www.darefoods.com/product/breton-original-crackers/",
            "https://www.pepsi.ca/products/pepsi-2l",
            "https://fevesclark.ca/en/our-beans/canned-beans/beans-with-tomato-sauce"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with valid website links",
              "sql": "SELECT code, product_name, link FROM products WHERE link IS NOT NULL AND link LIKE 'http%' LIMIT 50"
            },
            {
              "description": "Count products by website domain",
              "sql": "SELECT regexp_extract(link, 'https?://([^/]+)', 1) as domain, COUNT(*) as count FROM products WHERE link IS NOT NULL GROUP BY domain LIMIT 50"
            },
            {
              "description": "Find products with potentially broken links (HTTP instead of HTTPS)",
              "sql": "SELECT code, product_name, link FROM products WHERE link LIKE 'http://%' AND link NOT LIKE 'https://%' LIMIT 50"
            }
          ]
        },
        "main_countries_tags": {
          "type": "VARCHAR[]",
          "description": "An array of country tags indicating the main countries where a product is primarily sold or distributed. This field is typically computed from the countries_tags field which lists all countries where a product is sold.",
          "examples": [
            "[]",
            "[]",
            "[]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products by their main_countries_tags status",
              "sql": "SELECT CASE WHEN main_countries_tags IS NULL THEN 'null' WHEN main_countries_tags = '[]' THEN 'empty' ELSE 'has_countries' END as status, COUNT(*) as count FROM products GROUP BY status LIMIT 50"
            },
            {
              "description": "Find products with non-empty main_countries_tags",
              "sql": "SELECT code, product_name, main_countries_tags FROM products WHERE main_countries_tags IS NOT NULL AND main_countries_tags != '[]' LIMIT 50"
            },
            {
              "description": "Compare main_countries_tags with countries_tags field",
              "sql": "SELECT code, main_countries_tags, countries_tags FROM products WHERE countries_tags IS NOT NULL AND countries_tags != '[]' LIMIT 50"
            }
          ]
        },
        "manufacturing_places": {
          "type": "VARCHAR",
          "description": "Location where the product was manufactured or processed. Can contain single locations or multiple locations separated by commas. May include specific addresses, cities, regions, or countries. Values can be in different languages (English, French, etc.).",
          "examples": [
            "Canada",
            "Boisbriand,Québec",
            "General Mills Canada Corporation,Ontario,Mississauga"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products manufactured in a specific country (case-insensitive search)",
              "sql": "SELECT product_name, manufacturing_places FROM products WHERE manufacturing_places ILIKE '%canada%' ORDER BY product_name LIMIT 50"
            },
            {
              "description": "Get distribution of manufacturing locations with product counts",
              "sql": "SELECT manufacturing_places, COUNT(*) as product_count FROM products WHERE manufacturing_places IS NOT NULL GROUP BY manufacturing_places ORDER BY COUNT(*) DESC LIMIT 50"
            },
            {
              "description": "Find products with multiple manufacturing locations (contains comma)",
              "sql": "SELECT manufacturing_places, product_name FROM products WHERE manufacturing_places LIKE '%,%' AND manufacturing_places IS NOT NULL ORDER BY manufacturing_places LIMIT 50"
            }
          ]
        },
        "last_image_t": {
          "type": "BIGINT",
          "description": "Unix timestamp indicating when the product's image was last updated. Represents the number of seconds since the Unix epoch (January 1, 1970).",
          "examples": [
            "1737530184",
            "1737518406",
            "1737517336"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products with no images",
              "sql": "SELECT COUNT(*) as products_without_images FROM products WHERE last_image_t IS NULL"
            },
            {
              "description": "Get products updated in the last 30 days",
              "sql": "SELECT COUNT(*) as recent_updates FROM products WHERE last_image_t >= EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - INTERVAL '30 days')"
            },
            {
              "description": "Get the 10 most recently updated products",
              "sql": "SELECT code, product_name, last_image_t FROM products WHERE last_image_t IS NOT NULL ORDER BY last_image_t DESC LIMIT 10"
            }
          ]
        },
        "manufacturing_places_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized tags representing the manufacturing locations of food products. Can include cities, regions, states/provinces, and countries. Tags are typically lowercase and use hyphens as separators.",
          "examples": [
            [
              "st-hyacinthe-quebec"
            ],
            [
              "toronto-on",
              "canada"
            ],
            [
              "fairfield",
              "california",
              "usa"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products manufactured in a specific country",
              "sql": "SELECT product_name, manufacturing_places_tags FROM products WHERE list_contains(manufacturing_places_tags, 'canada') LIMIT 50"
            },
            {
              "description": "Get products with multiple manufacturing locations",
              "sql": "SELECT product_name, manufacturing_places_tags FROM products WHERE array_length(manufacturing_places_tags) > 1 ORDER BY array_length(manufacturing_places_tags) DESC LIMIT 50"
            },
            {
              "description": "Find most common manufacturing locations",
              "sql": "SELECT unnest(manufacturing_places_tags) as location, COUNT(*) as count FROM products WHERE manufacturing_places_tags IS NOT NULL GROUP BY location ORDER BY count DESC LIMIT 50"
            }
          ]
        },
        "max_imgid": {
          "type": "INTEGER",
          "description": "Represents the highest image ID associated with a product in the Open Food Facts database. This indicates the total number of images that have been uploaded for the product, with higher values suggesting products with more visual documentation.",
          "examples": [
            "151",
            "87",
            "82"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Categorize products based on their image count",
              "sql": "SELECT CASE WHEN max_imgid > 100 THEN 'Many images' WHEN max_imgid > 50 THEN 'Several images' WHEN max_imgid > 0 THEN 'Few images' ELSE 'No images' END as image_status, COUNT(*) as product_count FROM products GROUP BY 1 ORDER BY 2 DESC LIMIT 50;"
            },
            {
              "description": "Find products with above-average number of images",
              "sql": "SELECT code, max_imgid FROM products WHERE max_imgid > ( SELECT AVG(max_imgid) FROM products WHERE max_imgid IS NOT NULL ) ORDER BY max_imgid DESC LIMIT 50;"
            },
            {
              "description": "Distribution of products by image count ranges",
              "sql": "SELECT CASE WHEN max_imgid IS NULL THEN 'No images' WHEN max_imgid <= 10 THEN '1-10 images' WHEN max_imgid <= 50 THEN '11-50 images' ELSE 'Over 50 images' END as image_range, COUNT(*) as product_count FROM products GROUP BY 1 ORDER BY 2 DESC LIMIT 50;"
            }
          ]
        },
        "minerals_tags": {
          "type": "VARCHAR[]",
          "description": "An array of mineral ingredients found in food products, using the Open Food Facts taxonomy with 'en:' prefix. Includes both simple minerals (like 'en:iron') and specific mineral compounds (like 'en:calcium-chloride'). NULL when no minerals are listed.",
          "examples": [
            [
              "en:calcium-chloride",
              "en:sodium-phosphate",
              "en:calcium-sulfate"
            ],
            [
              "en:sodium",
              "en:potassium",
              "en:calcium"
            ],
            [
              "en:calcium-carbonate",
              "en:magnesium-oxide",
              "en:zinc-oxide",
              "en:copper-gluconate"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most common minerals and their frequency in products",
              "sql": "WITH RECURSIVE unnested AS ( SELECT UNNEST(minerals_tags) as mineral FROM products WHERE minerals_tags IS NOT NULL ) SELECT mineral, COUNT(*) as count FROM unnested GROUP BY mineral ORDER BY count DESC LIMIT 50;"
            },
            {
              "description": "Find products containing both calcium and iron",
              "sql": "SELECT code, product_name, minerals_tags FROM products WHERE minerals_tags IS NOT NULL AND (array_contains(minerals_tags, 'en:calcium') OR array_contains(minerals_tags, 'en:calcium-chloride') OR array_contains(minerals_tags, 'en:calcium-carbonate')) AND (array_contains(minerals_tags, 'en:iron') OR array_contains(minerals_tags, 'en:ferric-orthophosphate')) LIMIT 50;"
            },
            {
              "description": "Calculate the average number of minerals per product (excluding NULL)",
              "sql": "SELECT AVG(array_length(minerals_tags)) as avg_minerals_count, MIN(array_length(minerals_tags)) as min_minerals, MAX(array_length(minerals_tags)) as max_minerals FROM products WHERE minerals_tags IS NOT NULL LIMIT 50;"
            }
          ]
        },
        "misc_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags containing metadata about the product's data quality, scoring calculations (like Eco-Score), and administrative information. These tags typically indicate the status of various computations, data completeness, and quality checks.",
          "examples": [
            "['en:ecoscore-changed', 'en:ecoscore-computed', 'en:ecoscore-extended-data-not-computed']",
            "['en:all-ingredients-with-specified-percent', 'en:environmental-score-changed']",
            "['en:environmental-score-extended-data-not-computed', 'en:environmental-score-not-computed']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with specific quality indicators",
              "sql": "SELECT code, product_name, misc_tags FROM products WHERE array_contains(misc_tags, 'en:all-ingredients-with-specified-percent') LIMIT 50"
            },
            {
              "description": "Find products with computed Eco-Score",
              "sql": "SELECT code, product_name, misc_tags FROM products WHERE array_contains(misc_tags, 'en:ecoscore-computed') LIMIT 50"
            },
            {
              "description": "Count products by number of misc tags to assess data completeness",
              "sql": "SELECT array_length(misc_tags) as tag_count, COUNT(*) as product_count FROM products GROUP BY array_length(misc_tags) ORDER BY tag_count LIMIT 50"
            }
          ]
        },
        "new_additives_n": {
          "type": "INTEGER",
          "description": "Count of additives present in the product. Ranges from 0 (no additives) to 6 in the current dataset.",
          "examples": [
            "0",
            "1",
            "6"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with no additives",
              "sql": "SELECT code, product_name, new_additives_n FROM products WHERE new_additives_n = 0 LIMIT 50"
            },
            {
              "description": "Distribution of products by number of additives",
              "sql": "SELECT new_additives_n, COUNT(*) as product_count FROM products WHERE new_additives_n IS NOT NULL GROUP BY new_additives_n ORDER BY new_additives_n LIMIT 50"
            },
            {
              "description": "Find products with high number of additives (more than 3)",
              "sql": "SELECT code, product_name, new_additives_n FROM products WHERE new_additives_n > 3 ORDER BY new_additives_n DESC LIMIT 50"
            }
          ]
        },
        "no_nutrition_data": {
          "type": "BOOLEAN",
          "description": "Boolean flag indicating whether a product lacks nutrition data. When TRUE, it means the product has no nutrition information available. When FALSE, it means the product has some nutrition data. NULL values indicate unknown status.",
          "examples": [
            "True",
            "False",
            "False"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with no nutrition data available",
              "sql": "SELECT code, product_name FROM products WHERE no_nutrition_data = TRUE LIMIT 1000"
            },
            {
              "description": "Get distribution of products by nutrition data availability",
              "sql": "SELECT COUNT(*) as count, no_nutrition_data FROM products GROUP BY no_nutrition_data LIMIT 1000"
            },
            {
              "description": "List products with unknown nutrition data status",
              "sql": "SELECT code, product_name FROM products WHERE no_nutrition_data IS NULL LIMIT 1000"
            }
          ]
        },
        "nova_group": {
          "type": "INTEGER",
          "description": "The NOVA food classification group (1-4) indicating the degree of food processing. Group 1: Unprocessed/minimally processed foods; Group 2: Processed culinary ingredients; Group 3: Processed foods; Group 4: Ultra-processed foods. Higher numbers indicate more processing.",
          "examples": [
            "1",
            "2",
            "4"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Distribution of products by NOVA group with percentages",
              "sql": "SELECT nova_group, COUNT(*) as product_count, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM products WHERE nova_group IS NOT NULL), 2) as percentage FROM products WHERE nova_group IS NOT NULL GROUP BY nova_group ORDER BY nova_group LIMIT 50;"
            },
            {
              "description": "Find ultra-processed products (NOVA group 4)",
              "sql": "SELECT code, product_name, nova_group FROM products WHERE nova_group = 4 LIMIT 50;"
            },
            {
              "description": "Average NOVA group by food category",
              "sql": "SELECT categories_tags[1] as main_category, ROUND(AVG(nova_group), 2) as avg_nova, COUNT(*) as product_count FROM products WHERE nova_group IS NOT NULL GROUP BY categories_tags[1] HAVING COUNT(*) > 10 ORDER BY avg_nova DESC LIMIT 50;"
            }
          ]
        },
        "nova_groups": {
          "type": "VARCHAR",
          "description": "NOVA classification group (1-4) indicating the degree of food processing. Group 1: Unprocessed/minimally processed foods, Group 2: Processed culinary ingredients, Group 3: Processed foods, Group 4: Ultra-processed foods.",
          "examples": [
            "1",
            "2",
            "4"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Distribution of products by NOVA group to analyze processing levels",
              "sql": "SELECT nova_groups, COUNT(*) as product_count FROM products WHERE nova_groups IS NOT NULL GROUP BY nova_groups ORDER BY nova_groups LIMIT 50"
            },
            {
              "description": "Find all unprocessed or minimally processed foods (NOVA group 1)",
              "sql": "SELECT code, product_name, nova_groups FROM products WHERE nova_groups = '1' LIMIT 50"
            },
            {
              "description": "Percentage of ultra-processed foods (NOVA group 4) in the database",
              "sql": "SELECT ROUND(100.0 * COUNT(CASE WHEN nova_groups = '4' THEN 1 END) / COUNT(*), 2) as ultra_processed_percentage FROM products WHERE nova_groups IS NOT NULL LIMIT 50"
            }
          ]
        },
        "nova_groups_tags": {
          "type": "VARCHAR[]",
          "description": "Array containing NOVA food classification group tags. NOVA is a food classification system that categorizes foods according to their level of processing: from unprocessed (group 1) to ultra-processed (group 4). Also includes 'unknown' and 'not-applicable' values.",
          "examples": [
            "['en:1-unprocessed-or-minimally-processed-foods']",
            "['en:4-ultra-processed-food-and-drink-products']",
            "['en:3-processed-foods']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Distribution of products across NOVA groups",
              "sql": "SELECT nova_groups_tags, COUNT(*) as product_count FROM products WHERE nova_groups_tags IS NOT NULL GROUP BY nova_groups_tags ORDER BY product_count DESC LIMIT 50"
            },
            {
              "description": "Find products in a specific NOVA group (e.g., ultra-processed foods)",
              "sql": "SELECT code, product_name, nova_groups_tags FROM products WHERE nova_groups_tags = ARRAY['en:4-ultra-processed-food-and-drink-products'] LIMIT 50"
            },
            {
              "description": "Products with unknown or missing NOVA classification",
              "sql": "SELECT code, product_name, nova_groups_tags FROM products WHERE nova_groups_tags IS NULL OR nova_groups_tags = ARRAY['unknown'] LIMIT 50"
            }
          ]
        },
        "nucleotides_tags": {
          "type": "VARCHAR[]",
          "description": "An array of nucleotide additives present in food products, particularly common in infant formulas and specialized nutritional products. Each tag is prefixed with 'en:' and represents different types of nucleotides like adenosine-monophosphate, cytidine-monophosphate, etc.",
          "examples": [
            "['en:cytidine-monophosphate', 'en:disodium-guanosine-5-monophosphate', 'en:disodium-uridine-monophosphate']",
            "['en:adenosine-monophosphate']",
            "[]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products containing a specific nucleotide (e.g., adenosine-monophosphate)",
              "sql": "SELECT code, product_name, nucleotides_tags FROM products WHERE list_contains(nucleotides_tags, 'en:adenosine-monophosphate') LIMIT 50"
            },
            {
              "description": "Get frequency distribution of different nucleotides in products",
              "sql": "SELECT unnested.value as nucleotide, COUNT(*) as frequency FROM products, UNNEST(nucleotides_tags) as unnested(value) GROUP BY unnested.value ORDER BY frequency DESC LIMIT 50"
            },
            {
              "description": "Find products with multiple nucleotides (more than 2)",
              "sql": "SELECT code, product_name, nucleotides_tags, ARRAY_LENGTH(nucleotides_tags) as nucleotide_count FROM products WHERE ARRAY_LENGTH(nucleotides_tags) > 2 ORDER BY ARRAY_LENGTH(nucleotides_tags) DESC LIMIT 50"
            }
          ]
        },
        "nutriscore_grade": {
          "type": "VARCHAR",
          "description": "The Nutri-Score grade indicating the nutritional quality of a food product. Ranges from 'a' (best) to 'e' (worst), with 'not-applicable' and 'unknown' as special values. This score is calculated based on nutritional content including energy, saturated fat, sugars, sodium, fiber, proteins and proportion of fruits/vegetables.",
          "examples": [
            "a",
            "c",
            "e"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count of products by Nutri-Score grade with percentage distribution",
              "sql": "SELECT nutriscore_grade, COUNT(*) as count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage FROM products WHERE nutriscore_grade IS NOT NULL GROUP BY nutriscore_grade ORDER BY nutriscore_grade LIMIT 50"
            },
            {
              "description": "Find products with the healthiest Nutri-Score (grade 'a')",
              "sql": "SELECT code, product_name, nutriscore_grade FROM products WHERE nutriscore_grade = 'a' LIMIT 50"
            },
            {
              "description": "Compare Nutri-Score distribution across different food categories",
              "sql": "SELECT categories_tags, nutriscore_grade, COUNT(*) as count FROM products WHERE nutriscore_grade IS NOT NULL GROUP BY categories_tags, nutriscore_grade LIMIT 50"
            }
          ]
        },
        "nutriscore_score": {
          "type": "INTEGER",
          "description": "Numerical score used in the Nutri-Score nutrition labeling system. Ranges from -17 (most healthy) to 47 (least healthy). The score considers various nutritional aspects of the product, with lower scores indicating better nutritional quality.",
          "examples": [
            "-15",
            "0",
            "25"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find healthiest products by Nutri-Score",
              "sql": "SELECT code, product_name, nutriscore_score FROM products WHERE nutriscore_score IS NOT NULL ORDER BY nutriscore_score ASC LIMIT 50"
            },
            {
              "description": "Group products by Nutri-Score range and count them",
              "sql": "SELECT CASE WHEN nutriscore_score < 0 THEN 'Very Good' WHEN nutriscore_score < 10 THEN 'Good' WHEN nutriscore_score < 20 THEN 'Average' WHEN nutriscore_score < 30 THEN 'Poor' ELSE 'Very Poor' END as quality_category, COUNT(*) as product_count FROM products WHERE nutriscore_score IS NOT NULL GROUP BY quality_category ORDER BY MIN(nutriscore_score) LIMIT 50"
            },
            {
              "description": "Calculate average Nutri-Score by product category",
              "sql": "SELECT categories, ROUND(AVG(nutriscore_score), 2) as avg_score, COUNT(*) as product_count FROM products WHERE nutriscore_score IS NOT NULL AND categories IS NOT NULL GROUP BY categories ORDER BY avg_score ASC LIMIT 50"
            }
          ]
        },
        "nutrient_levels_tags": {
          "type": "VARCHAR[]",
          "description": "Array of tags indicating the levels (low, moderate, high) of different nutrients (fat, saturated fat, sugars, salt) in food products. Each tag follows the format 'en:nutrient-in-level-quantity'.",
          "examples": [
            "['en:fat-in-low-quantity', 'en:saturated-fat-in-low-quantity', 'en:sugars-in-low-quantity', 'en:salt-in-low-quantity']",
            "['en:fat-in-high-quantity', 'en:saturated-fat-in-moderate-quantity', 'en:sugars-in-moderate-quantity']",
            "['en:fat-in-moderate-quantity', 'en:saturated-fat-in-low-quantity', 'en:salt-in-high-quantity']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products by fat level",
              "sql": "WITH unnested AS (SELECT unnest(nutrient_levels_tags) as level FROM products WHERE nutrient_levels_tags IS NOT NULL) SELECT level, COUNT(*) as count FROM unnested WHERE level LIKE 'en:fat-in-%' GROUP BY level ORDER BY count DESC LIMIT 50"
            },
            {
              "description": "Find products with all nutrients in low quantity",
              "sql": "SELECT code, product_name, nutrient_levels_tags FROM products WHERE nutrient_levels_tags IS NOT NULL AND array_contains(nutrient_levels_tags, 'en:fat-in-low-quantity') AND array_contains(nutrient_levels_tags, 'en:saturated-fat-in-low-quantity') AND array_contains(nutrient_levels_tags, 'en:sugars-in-low-quantity') AND array_contains(nutrient_levels_tags, 'en:salt-in-low-quantity') LIMIT 50"
            },
            {
              "description": "Find products with any high-quantity nutrients",
              "sql": "SELECT code, product_name, nutrient_levels_tags FROM products WHERE nutrient_levels_tags IS NOT NULL AND (array_contains(nutrient_levels_tags, 'en:fat-in-high-quantity') OR array_contains(nutrient_levels_tags, 'en:saturated-fat-in-high-quantity') OR array_contains(nutrient_levels_tags, 'en:sugars-in-high-quantity') OR array_contains(nutrient_levels_tags, 'en:salt-in-high-quantity')) LIMIT 50"
            }
          ]
        },
        "nutrition_data_per": {
          "type": "VARCHAR",
          "description": "Indicates the base unit for nutritional values in the product. Can be either '100g' (for 100 grams of product) or 'serving' (for one serving). This field is crucial for interpreting nutritional information correctly.",
          "examples": [
            "100g",
            "serving",
            ""
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Distribution of nutrition data base units across products",
              "sql": "SELECT nutrition_data_per, COUNT(*) as product_count FROM products GROUP BY nutrition_data_per ORDER BY product_count DESC LIMIT 50"
            },
            {
              "description": "Find products with nutritional data per serving and their serving size",
              "sql": "SELECT code, product_name, serving_size FROM products WHERE nutrition_data_per = 'serving' AND serving_size IS NOT NULL LIMIT 50"
            },
            {
              "description": "Compare products with missing or invalid nutrition data unit",
              "sql": "SELECT code, product_name FROM products WHERE nutrition_data_per IS NULL OR nutrition_data_per = '' LIMIT 50"
            }
          ]
        },
        "obsolete": {
          "type": "BOOLEAN",
          "description": "A boolean flag indicating whether a product is obsolete/discontinued. Currently all products in the database are marked as not obsolete (FALSE).",
          "examples": [
            "False",
            "False",
            "False"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count of products by obsolete status",
              "sql": "SELECT obsolete, COUNT(*) as product_count FROM products GROUP BY obsolete LIMIT 50"
            },
            {
              "description": "Find products with their obsolete status and last modification date",
              "sql": "SELECT code, product_name, obsolete, last_modified_t FROM products WHERE obsolete IS NOT NULL ORDER BY last_modified_t DESC LIMIT 50"
            },
            {
              "description": "Compare number of obsolete vs active products by brand",
              "sql": "SELECT brands, COUNT(*) as total_products, SUM(CASE WHEN obsolete THEN 1 ELSE 0 END) as obsolete_products FROM products GROUP BY brands HAVING brands IS NOT NULL LIMIT 50"
            }
          ]
        },
        "nutriments": {
          "type": "STRUCT(name VARCHAR, value FLOAT, 100g FLOAT, serving FLOAT, unit VARCHAR)[]",
          "description": "Array of nutritional information structures for products. Each nutriment entry contains the nutrient name, its value per 100g, per serving, and measurement unit. Common nutrients include energy, proteins, carbohydrates, fats, fiber, etc.",
          "examples": [
            "[{'name': 'energy', 'value': 233.33, '100g': 976.0, 'serving': 146.0, 'unit': 'kcal'}]",
            "[{'name': 'proteins', 'value': 4.0, '100g': 4.0, 'serving': null, 'unit': 'g'}]",
            "[{'name': 'carbohydrates', 'value': 24.0, '100g': 24.0, 'serving': 7.2, 'unit': 'g'}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get products with their nutriment information",
              "sql": "SELECT code, nutriments FROM products WHERE nutriments IS NOT NULL LIMIT 50"
            },
            {
              "description": "Find products with non-empty nutriment information",
              "sql": "SELECT code, nutriments FROM products WHERE nutriments IS NOT NULL AND length(nutriments) > 0 LIMIT 50"
            },
            {
              "description": "Get products with specific nutriment types",
              "sql": "SELECT code, nutriments FROM products WHERE nutriments IS NOT NULL AND length(nutriments) > 0 AND list_contains(list_transform(nutriments, x -> x.name), 'energy') LIMIT 50"
            }
          ]
        },
        "origins": {
          "type": "VARCHAR",
          "description": "Indicates the geographical origin of food products, including manufacturing locations, source countries, and regions. Can contain single locations, multiple locations separated by commas, or processing information. May include specific cities, regions, countries, or manufacturing facilities.",
          "examples": [
            "Canada",
            "Product of USA,Kashi Company,California,Solara Beach",
            "Made in Canada from imported ingredients"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get most common product origins with their counts",
              "sql": "SELECT origins, COUNT(*) as product_count FROM products WHERE origins IS NOT NULL GROUP BY origins ORDER BY product_count DESC LIMIT 50"
            },
            {
              "description": "Find products with multiple origin locations (containing commas)",
              "sql": "SELECT code, product_name, origins FROM products WHERE origins LIKE '%,%' AND origins IS NOT NULL LIMIT 50"
            },
            {
              "description": "Find products from a specific country (case-insensitive)",
              "sql": "SELECT code, product_name, origins FROM products WHERE origins ILIKE '%canada%' OR origins ILIKE '%canadian%' LIMIT 50"
            }
          ]
        },
        "origins_tags": {
          "type": "VARCHAR[]",
          "description": "An array of strings indicating the geographical origins of products, with language prefixes (e.g., 'en:', 'fr:'). Can include countries, regions, cities, or manufacturing locations. Each tag is prefixed with a language code and contains the location information.",
          "examples": [
            "['en:canada', 'en:st-hyacinthe-quebec-canada']",
            "['fr:quebec']",
            "['en:canada', 'en:brazil', 'en:thailand']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get distribution of products by language prefix in origins",
              "sql": "SELECT CASE WHEN origins_tags[1] LIKE 'en:%' THEN 'English' WHEN origins_tags[1] LIKE 'fr:%' THEN 'French' WHEN origins_tags[1] LIKE 'es:%' THEN 'Spanish' ELSE 'Other' END as language, COUNT(*) as count FROM products WHERE origins_tags IS NOT NULL GROUP BY 1 LIMIT 50;"
            },
            {
              "description": "Find products from a specific country (e.g., Canada)",
              "sql": "SELECT code, product_name, origins_tags FROM products WHERE list_contains(origins_tags, 'en:canada') LIMIT 50;"
            },
            {
              "description": "Analyze distribution of products by number of origin locations",
              "sql": "SELECT array_length(origins_tags) as num_origins, COUNT(*) as product_count FROM products WHERE origins_tags IS NOT NULL GROUP BY 1 ORDER BY 1 LIMIT 50;"
            }
          ]
        },
        "owner": {
          "type": "VARCHAR",
          "description": "Organization identifier that owns or has contributed the product data to Open Food Facts, typically in the format 'org-{organization-name}'. This field helps track which organizations are responsible for product data submissions.",
          "examples": [
            "org-carrefour",
            "org-nestle-france",
            "org-mincavi"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the top organizations by number of products contributed",
              "sql": "SELECT owner, COUNT(*) as product_count FROM products WHERE owner IS NOT NULL GROUP BY owner ORDER BY product_count DESC LIMIT 50"
            },
            {
              "description": "Get products from a specific organization (e.g., Carrefour)",
              "sql": "SELECT code, product_name, brands FROM products WHERE owner = 'org-carrefour' LIMIT 50"
            },
            {
              "description": "Get statistics about owner field usage",
              "sql": "SELECT COUNT(*) as total_products, COUNT(CASE WHEN owner IS NOT NULL THEN 1 END) as products_with_owner, COUNT(DISTINCT owner) as unique_owners FROM products LIMIT 50"
            }
          ]
        },
        "owner_fields": {
          "type": "STRUCT(field_name VARCHAR, timestamp BIGINT)[]",
          "description": "Tracks the modification history of product fields, storing which fields were modified and when. Each entry contains the field name and a UNIX timestamp of when the modification occurred.",
          "examples": [
            "[{'field_name': 'countries', 'timestamp': 1736827489}, {'field_name': 'sugars', 'timestamp': 1736827489}]",
            "[{'field_name': 'serving_size', 'timestamp': 1702571947}, {'field_name': 'carbohydrates', 'timestamp': 1702571947}]",
            "[{'field_name': 'nutrition_data_prepared_per', 'timestamp': 1581074862}, {'field_name': 'preparation', 'timestamp': 1581074862}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with recent modifications (in the last 30 days)",
              "sql": "SELECT code, UNNEST(owner_fields).field_name as modified_field, UNNEST(owner_fields).timestamp as modification_time FROM products WHERE owner_fields IS NOT NULL AND UNNEST(owner_fields).timestamp >= (EXTRACT(EPOCH FROM CURRENT_DATE) - 30 * 24 * 3600) LIMIT 50"
            },
            {
              "description": "Count number of modified fields per product",
              "sql": "SELECT code, array_length(owner_fields) as number_of_modifications FROM products WHERE owner_fields IS NOT NULL ORDER BY array_length(owner_fields) DESC LIMIT 50"
            },
            {
              "description": "Find products where specific fields were modified",
              "sql": "SELECT code, owner_fields FROM products WHERE owner_fields IS NOT NULL AND EXISTS( SELECT 1 FROM UNNEST(owner_fields) f WHERE f.field_name IN ('nutrition_data', 'ingredients_text') ) LIMIT 50"
            }
          ]
        },
        "packaging": {
          "type": "VARCHAR",
          "description": "Describes the packaging material and type of food products. Can include multiple components separated by commas. Values can be in English or French (e.g., 'Plastique'/'Plastic'). Common entries include materials (plastic, glass, metal), container types (bottle, box, bag), and packaging characteristics.",
          "examples": [
            "Plastic, Box, Pet-unknown",
            "Metal,Paper,Recyclable Metals,Aluminium",
            "Boite carton, Bouteille verre, Papiers bonbons"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get most common packaging types with their counts",
              "sql": "SELECT packaging, COUNT(*) as count FROM products WHERE packaging IS NOT NULL AND packaging != '' GROUP BY packaging ORDER BY count DESC LIMIT 1000"
            },
            {
              "description": "Find products with multiple packaging materials (contains comma)",
              "sql": "SELECT code, packaging FROM products WHERE packaging LIKE '%,%' AND packaging IS NOT NULL LIMIT 1000"
            },
            {
              "description": "Find products with specific packaging material (plastic/plastique)",
              "sql": "SELECT code, packaging FROM products WHERE LOWER(packaging) LIKE '%plastic%' OR LOWER(packaging) LIKE '%plastique%' LIMIT 1000"
            }
          ]
        },
        "packaging_recycling_tags": {
          "type": "VARCHAR[]",
          "description": "Array of recycling instructions and packaging disposal information in English. Each instruction is prefixed with 'en:' and contains details about how to recycle or dispose of the product packaging.",
          "examples": [
            "['en:Rinse, Insert Lid & Recycle in Metals bin', 'en:recycle-in-paper-bin']",
            "['en:Discard in Garbage bin.']",
            "['en:Wash & Recycle with Soft Plastics.']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with multiple recycling instructions",
              "sql": "SELECT code, packaging_recycling_tags, array_length(packaging_recycling_tags) as instruction_count FROM products WHERE array_length(packaging_recycling_tags) > 1 LIMIT 50"
            },
            {
              "description": "Find products with specific recycling tag (recycle with plastics)",
              "sql": "SELECT code, packaging_recycling_tags FROM products WHERE packaging_recycling_tags IS NOT NULL AND array_contains(packaging_recycling_tags, 'en:recycle-with-plastics') LIMIT 50"
            },
            {
              "description": "Find products with discard instructions",
              "sql": "SELECT code, packaging_recycling_tags FROM products WHERE packaging_recycling_tags IS NOT NULL AND array_contains(packaging_recycling_tags, 'en:discard') LIMIT 50"
            }
          ]
        },
        "packaging_shapes_tags": {
          "type": "VARCHAR[]",
          "description": "An array of packaging shape tags that describe the physical form and components of product packaging. Each tag is prefixed with 'en:' and can include both standard shapes (like bottle, bag, box) and detailed descriptions of specific packaging features.",
          "examples": [
            [
              "en:bottle",
              "en:lid-or-cap"
            ],
            [
              "en:box",
              "en:film",
              "en:wrapper"
            ],
            [
              "en:jar",
              "en:lid",
              "en:label"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get the most common packaging shapes with their frequencies",
              "sql": "WITH exploded AS ( SELECT UNNEST(packaging_shapes_tags) as shape FROM products WHERE packaging_shapes_tags IS NOT NULL ) SELECT REPLACE(shape, 'en:', '') as clean_shape, COUNT(*) as frequency FROM exploded GROUP BY shape ORDER BY frequency DESC LIMIT 50"
            },
            {
              "description": "Find products with multiple packaging components (3 or more shapes)",
              "sql": "SELECT code, product_name, packaging_shapes_tags FROM products WHERE ARRAY_LENGTH(packaging_shapes_tags) >= 3 LIMIT 50"
            },
            {
              "description": "Find products with specific packaging shape combinations (e.g., bottle and cap)",
              "sql": "SELECT code, product_name, packaging_shapes_tags FROM products WHERE list_contains(packaging_shapes_tags, 'en:bottle') AND list_contains(packaging_shapes_tags, 'en:bottle-cap') LIMIT 50"
            }
          ]
        },
        "packaging_text": {
          "type": "STRUCT(lang VARCHAR, text VARCHAR)[]",
          "description": "Contains packaging information in different languages, describing materials, recycling instructions, and packaging components. Each entry is a structured array with language code and text description.",
          "examples": [
            "[{'lang': 'main', 'text': '1 paper box to recycle\\r\\n12 plastic wrappers to recycle'}]",
            "[{'lang': 'main', 'text': '7 BPA-Free Sans BPA'}, {'lang': 'en', 'text': '7 BPA-Free Sans BPA'}]",
            "[{'lang': 'main', 'text': '1 plastic bag'}, {'lang': 'en', 'text': '1 plastic bag'}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with multiple packaging components (containing multiple lines)",
              "sql": "SELECT code, packaging_text FROM products WHERE packaging_text IS NOT NULL AND contains(packaging_text[0].text, '\\n') LIMIT 50"
            },
            {
              "description": "Get products with packaging information in multiple languages",
              "sql": "SELECT code, packaging_text FROM products WHERE packaging_text IS NOT NULL AND ARRAY_LENGTH(packaging_text) > 1 LIMIT 50"
            },
            {
              "description": "Find products with glass packaging",
              "sql": "SELECT code, packaging_text FROM products WHERE packaging_text IS NOT NULL AND LOWER(packaging_text[0].text) LIKE '%glass%' OR LOWER(packaging_text[0].text) LIKE '%verre%' LIMIT 50"
            }
          ]
        },
        "packagings": {
          "type": "STRUCT(material VARCHAR, number_of_units BIGINT, quantity_per_unit VARCHAR, quantity_per_unit_unit VARCHAR)[]",
          "description": "Array of packaging information for products, including material type, number of units, and quantity measurements. Materials are prefixed with 'en:' and include common types like glass, plastic, cardboard, etc.",
          "examples": [
            "[{'material': 'en:glass', 'number_of_units': 1, 'quantity_per_unit': 'holds 235 ml product', 'quantity_per_unit_unit': 'ml'}]",
            "[{'material': 'en:plastic', 'number_of_units': 2, 'quantity_per_unit': None, 'quantity_per_unit_unit': None}]",
            "[{'material': 'en:cardboard', 'number_of_units': 1, 'quantity_per_unit': None, 'quantity_per_unit_unit': None}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with glass packaging",
              "sql": "SELECT code, product_name, packagings FROM products WHERE list_contains(list_transform(packagings, x -> x.material), 'en:glass') LIMIT 50"
            },
            {
              "description": "Find products with multiple packagings",
              "sql": "SELECT code, packagings FROM products WHERE packagings IS NOT NULL AND array_length(packagings) > 1 LIMIT 50"
            },
            {
              "description": "Find products with packagings containing more than 1 unit",
              "sql": "SELECT code, packagings FROM products WHERE packagings IS NOT NULL AND packagings[1].number_of_units > 1 LIMIT 50"
            }
          ]
        },
        "packagings_complete": {
          "type": "BOOLEAN",
          "description": "Indicates whether the packaging information for a product is complete. When TRUE, it means all packaging details have been fully documented. Most products (about 93%) have NULL values, while among non-NULL values, approximately 12% are TRUE and 88% are FALSE.",
          "examples": [
            "True",
            "False",
            "NULL"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with complete packaging information",
              "sql": "SELECT code, product_name, packagings_complete FROM products WHERE packagings_complete = TRUE LIMIT 50"
            },
            {
              "description": "Get distribution of packaging completeness status",
              "sql": "SELECT packagings_complete, COUNT(*) as count FROM products GROUP BY packagings_complete LIMIT 50"
            },
            {
              "description": "Find recently modified products with incomplete packaging information",
              "sql": "SELECT code, product_name, packagings_complete, last_modified_t FROM products WHERE packagings_complete = FALSE ORDER BY last_modified_t DESC LIMIT 50"
            }
          ]
        },
        "packaging_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags describing the packaging materials and types used for the product. Tags use prefixes 'en:' for English and 'fr:' for French descriptions, including materials (like plastic, glass, metal), forms (bottle, box, bag), and characteristics (fresh, frozen).",
          "examples": [
            "['en:plastic', 'en:bottle']",
            "['en:glass', 'en:bottle', 'fr:bouteille-en-verre']",
            "['en:aluminium-can', 'en:pp-wrapper']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with a specific packaging material (e.g., glass)",
              "sql": "SELECT code, product_name, packaging_tags FROM products WHERE list_contains(packaging_tags, 'en:glass') LIMIT 50"
            },
            {
              "description": "Analyze distribution of number of packaging materials per product",
              "sql": "SELECT ARRAY_LENGTH(packaging_tags) as num_materials, COUNT(*) as product_count FROM products WHERE packaging_tags IS NOT NULL GROUP BY ARRAY_LENGTH(packaging_tags) ORDER BY num_materials LIMIT 50"
            },
            {
              "description": "Find products with complex packaging (more than 2 materials/types)",
              "sql": "SELECT code, product_name, packaging_tags FROM products WHERE ARRAY_LENGTH(packaging_tags) > 2 LIMIT 50"
            }
          ]
        },
        "photographers": {
          "type": "VARCHAR[]",
          "description": "Array of usernames of contributors who photographed the product for Open Food Facts. These photographers help document products by submitting photos to the database.",
          "examples": [
            "['grdscarabe']",
            "['manu1400', 'andre']",
            "['julia-t']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products photographed by a specific contributor",
              "sql": "SELECT code, product_name, photographers FROM products WHERE list_contains(photographers, 'manu1400') LIMIT 50"
            },
            {
              "description": "Count number of photographers per product",
              "sql": "SELECT array_length(photographers) as photographer_count, COUNT(*) as products FROM products WHERE photographers IS NOT NULL GROUP BY array_length(photographers) ORDER BY photographer_count LIMIT 50"
            },
            {
              "description": "Find products with multiple photographers",
              "sql": "SELECT code, product_name, photographers FROM products WHERE array_length(photographers) > 1 LIMIT 50"
            }
          ]
        },
        "popularity_key": {
          "type": "BIGINT",
          "description": "A numerical score indicating product popularity in the Open Food Facts database. Higher values (like 22999950563) indicate more popular products, while lower or negative values (down to -200000000000) indicate less popular items. This score appears to be a timestamp-based ranking system.",
          "examples": [
            "22999950563",
            "22999900475",
            "-200000000000"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the top 10 most popular products",
              "sql": "SELECT popularity_key, product_name FROM products WHERE popularity_key IS NOT NULL ORDER BY popularity_key DESC LIMIT 10"
            },
            {
              "description": "Get distribution of popularity ranges",
              "sql": "SELECT CASE WHEN popularity_key > 22999900000 THEN 'Very Popular' WHEN popularity_key > 0 THEN 'Popular' ELSE 'Less Popular' END as popularity_range, COUNT(*) as product_count FROM products GROUP BY popularity_range LIMIT 50"
            },
            {
              "description": "Find products with unusually low popularity scores",
              "sql": "SELECT product_name, popularity_key FROM products WHERE popularity_key < 0 ORDER BY popularity_key ASC LIMIT 50"
            }
          ]
        },
        "popularity_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags indicating product popularity based on scan statistics. Tags include yearly scanning rankings (e.g., 'top-100000-scans-2023'), percentile-based statistics (e.g., 'top-85-percent-scans-2023'), and country-specific popularity (e.g., 'top-country-fr-scans-2023'). These tags help track product popularity across different timeframes and regions.",
          "examples": [
            "['top-country-fr-scans-2019']",
            "['top-100000-scans-2019', 'top-country-fr-scans-2019']",
            "['top-75-percent-scans-2023', 'top-80-percent-scans-2023', 'top-85-percent-scans-2023']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with the most popularity tags, showing highly tracked products",
              "sql": "SELECT code, popularity_tags FROM products WHERE array_length(popularity_tags) > 10 ORDER BY array_length(popularity_tags) DESC LIMIT 50"
            },
            {
              "description": "Find products popular in Canada in 2023",
              "sql": "SELECT code, popularity_tags FROM products WHERE popularity_tags && ['top-country-ca-scans-2023'] LIMIT 50"
            },
            {
              "description": "Analyze the distribution of popularity tag counts across products",
              "sql": "SELECT COUNT(*) as product_count, array_length(popularity_tags) as tag_count FROM products WHERE popularity_tags IS NOT NULL GROUP BY array_length(popularity_tags) ORDER BY tag_count LIMIT 50"
            }
          ]
        },
        "product_name": {
          "type": "STRUCT(lang VARCHAR, text VARCHAR)[]",
          "description": "Multilingual product names stored as an array of structures containing language code ('lang') and product name ('text'). Each product typically has a main name and translations in different languages (mainly English and French for the Canadian database).",
          "examples": [
            "[{'lang': 'main', 'text': 'Organic Vermont Maple Syrup'}, {'lang': 'fr', 'text': '100 pure vermont organic maple syrup'}]",
            "[{'lang': 'main', 'text': 'Fresh udon bowl'}, {'lang': 'fr', 'text': 'Fresh udon bowl'}]",
            "[{'lang': 'main', 'text': '1% low-fat milk'}, {'lang': 'en', 'text': '1% low-fat milk'}]"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with multiple language translations (more than one name)",
              "sql": "SELECT code, product_name FROM products WHERE ARRAY_LENGTH(product_name) > 1 LIMIT 50"
            },
            {
              "description": "Get French product names where available",
              "sql": "SELECT code, UNNEST(LIST_FILTER(product_name, x -> x.lang = 'fr')).text AS french_name FROM products WHERE LIST_FILTER(product_name, x -> x.lang = 'fr') IS NOT NULL LIMIT 50"
            },
            {
              "description": "Analyze translation coverage by counting products with different numbers of translations",
              "sql": "SELECT ARRAY_LENGTH(product_name) as translation_count, COUNT(*) as product_count FROM products WHERE product_name IS NOT NULL GROUP BY ARRAY_LENGTH(product_name) ORDER BY translation_count LIMIT 50"
            }
          ]
        },
        "product_quantity": {
          "type": "VARCHAR",
          "description": "Normalized quantity of the product in grams (for solids) or milliliters (for liquids). This is a computed field that standardizes various quantity formats (e.g., '1,5 L' becomes '1500', '2 x 160 g' becomes '320') to a single numeric value for easier analysis.",
          "examples": [
            "500.0",
            "1000",
            "0.75"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with unusual quantities (very small or very large)",
              "sql": "SELECT code, product_name, product_quantity FROM products WHERE CAST(product_quantity AS DOUBLE) < 1 OR CAST(product_quantity AS DOUBLE) > 10000 LIMIT 50"
            },
            {
              "description": "Get most common product quantities to understand standard packaging sizes",
              "sql": "SELECT product_quantity, COUNT(*) as count FROM products WHERE product_quantity IS NOT NULL GROUP BY product_quantity ORDER BY count DESC LIMIT 50"
            },
            {
              "description": "Calculate average and median product quantities",
              "sql": "SELECT ROUND(AVG(CAST(product_quantity AS DOUBLE)), 2) as avg_quantity, ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY CAST(product_quantity AS DOUBLE)), 2) as median_quantity FROM products WHERE product_quantity IS NOT NULL LIMIT 50"
            }
          ]
        },
        "product_quantity_unit": {
          "type": "VARCHAR",
          "description": "Unit of measurement for the product quantity. Only two possible values: 'g' for solid products (grams) or 'ml' for liquid products (milliliters).",
          "examples": [
            "g",
            "ml",
            "ml"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Get statistics about product quantities by unit type",
              "sql": "SELECT product_quantity_unit, COUNT(*) as count, MIN(CAST(product_quantity AS FLOAT)) as min_quantity, MAX(CAST(product_quantity AS FLOAT)) as max_quantity, AVG(CAST(product_quantity AS FLOAT)) as avg_quantity FROM products WHERE product_quantity_unit IS NOT NULL GROUP BY product_quantity_unit LIMIT 50;"
            },
            {
              "description": "Find large volume beverages (over 1 liter)",
              "sql": "SELECT product_name_en, product_quantity, product_quantity_unit FROM products WHERE CAST(product_quantity AS FLOAT) > 1000 AND product_quantity_unit = 'ml' LIMIT 50;"
            },
            {
              "description": "Distribution of products by type (solid vs liquid)",
              "sql": "SELECT CASE WHEN product_quantity_unit = 'ml' THEN 'Beverage' WHEN product_quantity_unit = 'g' THEN 'Solid food' ELSE 'Unknown' END as product_type, COUNT(*) as count FROM products WHERE product_quantity_unit IS NOT NULL GROUP BY product_type LIMIT 50;"
            }
          ]
        },
        "purchase_places_tags": {
          "type": "VARCHAR[]",
          "description": "An array of location tags indicating where the product was purchased, typically containing hierarchical location information (city, province/state, country). The tags are normalized (lowercase, hyphenated) location names.",
          "examples": [
            "['calgary', 'alberta', 'canada']",
            "['paris-xiii', 'paris', 'france', 'canberra', 'australia', 'montreal', 'canada']",
            "['brossard', 'quebea']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with their purchase locations and the number of location tags",
              "sql": "SELECT code, purchase_places_tags, array_length(purchase_places_tags) as location_count FROM products WHERE purchase_places_tags IS NOT NULL AND array_length(purchase_places_tags) > 0 LIMIT 50"
            },
            {
              "description": "Find products purchased in a specific country (e.g., Canada)",
              "sql": "SELECT code, purchase_places_tags FROM products WHERE purchase_places_tags IS NOT NULL AND list_contains(purchase_places_tags, 'canada') LIMIT 50"
            },
            {
              "description": "Find products with multiple purchase locations (more than 2 location tags)",
              "sql": "SELECT code, purchase_places_tags FROM products WHERE purchase_places_tags IS NOT NULL AND array_length(purchase_places_tags) > 2 ORDER BY array_length(purchase_places_tags) DESC LIMIT 50"
            }
          ]
        },
        "quantity": {
          "type": "VARCHAR",
          "description": "Product quantity or volume information, including weight, volume, or unit count. Can be expressed in various units (g, kg, ml, L) and formats, including multi-unit packages and mixed unit representations.",
          "examples": [
            "1 lb 1.88 oz (506 g)",
            "946 ml",
            "5 x 40g • 200g Net Wt."
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products by weight (grams)",
              "sql": "SELECT code, product_name, quantity FROM products WHERE quantity ILIKE '%g)%' OR quantity ILIKE '%g %' OR quantity ILIKE '%g$' LIMIT 50"
            },
            {
              "description": "Find products by liquid volume (ml or L)",
              "sql": "SELECT code, product_name, quantity FROM products WHERE quantity ILIKE '%ml%' OR quantity ILIKE '%l%' LIMIT 50"
            },
            {
              "description": "Find multi-unit packages",
              "sql": "SELECT code, product_name, quantity FROM products WHERE quantity LIKE '%x%' OR quantity LIKE '%X%' OR quantity LIKE '%;%' LIMIT 50"
            }
          ]
        },
        "rev": {
          "type": "INTEGER",
          "description": "Revision counter tracking the number of times a product has been modified in the database. Values range from 1 to 425, with most products having less than 50 revisions. This counter helps track product data history and update frequency.",
          "examples": [
            "1",
            "42",
            "425"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with high number of revisions (over 100 updates)",
              "sql": "SELECT code, rev FROM products WHERE rev > 100 ORDER BY rev DESC LIMIT 50"
            },
            {
              "description": "Get distribution of products across revision ranges",
              "sql": "SELECT CASE WHEN rev <= 10 THEN '1-10' WHEN rev <= 50 THEN '11-50' WHEN rev <= 100 THEN '51-100' ELSE 'over 100' END as revision_range, COUNT(*) as product_count FROM products GROUP BY 1 ORDER BY CASE revision_range WHEN '1-10' THEN 1 WHEN '11-50' THEN 2 WHEN '51-100' THEN 3 ELSE 4 END LIMIT 50"
            },
            {
              "description": "Find products with the most recent revisions",
              "sql": "SELECT code, rev FROM products WHERE rev = (SELECT MAX(rev) FROM products) LIMIT 50"
            }
          ]
        },
        "scans_n": {
          "type": "INTEGER",
          "description": "Number of times a product has been scanned by users in the Open Food Facts app. Higher values indicate more frequently scanned products. Most products have 1-10 scans, with only a small number having over 100 scans.",
          "examples": [
            "603",
            "596",
            "1"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most frequently scanned products",
              "sql": "SELECT code, product_name, scans_n FROM products WHERE scans_n IS NOT NULL ORDER BY scans_n DESC LIMIT 50"
            },
            {
              "description": "Get the distribution of scan frequencies across products",
              "sql": "SELECT CASE WHEN scans_n <= 10 THEN '1-10' WHEN scans_n <= 50 THEN '11-50' WHEN scans_n <= 100 THEN '51-100' ELSE 'over 100' END as scan_range, COUNT(*) as product_count FROM products WHERE scans_n IS NOT NULL GROUP BY scan_range ORDER BY scan_range LIMIT 50"
            },
            {
              "description": "Find products with above-average number of scans",
              "sql": "SELECT code, product_name, scans_n FROM products WHERE scans_n > ( SELECT AVG(scans_n) FROM products WHERE scans_n IS NOT NULL ) ORDER BY scans_n DESC LIMIT 50"
            }
          ]
        },
        "serving_quantity": {
          "type": "VARCHAR",
          "description": "Numeric value representing the quantity of a single serving of the product, typically expressed in grams or milliliters. Values range from 0 to 4540, with an average around 100.",
          "examples": [
            "40.0",
            "226.0",
            "0.6"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with unusually large serving sizes (above 95th percentile)",
              "sql": "SELECT code, product_name, serving_quantity FROM products WHERE TRY_CAST(serving_quantity AS DOUBLE) > (SELECT PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY TRY_CAST(serving_quantity AS DOUBLE)) FROM products) AND serving_quantity IS NOT NULL LIMIT 50"
            },
            {
              "description": "Get products with serving sizes between 50 and 100 units",
              "sql": "SELECT code, product_name, serving_quantity FROM products WHERE TRY_CAST(serving_quantity AS DOUBLE) BETWEEN 50 AND 100 AND serving_quantity IS NOT NULL ORDER BY TRY_CAST(serving_quantity AS DOUBLE) LIMIT 50"
            },
            {
              "description": "Calculate average serving size by product category",
              "sql": "SELECT categories, AVG(TRY_CAST(serving_quantity AS DOUBLE)) as avg_serving_size, COUNT(*) as product_count FROM products WHERE serving_quantity IS NOT NULL GROUP BY categories HAVING COUNT(*) > 5 ORDER BY avg_serving_size DESC LIMIT 50"
            }
          ]
        },
        "serving_size": {
          "type": "VARCHAR",
          "description": "Represents the recommended serving size of a product, including measurements in weight (g), volume (ml), or portion counts. Can contain multiple formats such as '1 cup (250 ml)' or '2 cookies (30 g)'. Values may be in English or French.",
          "examples": [
            "1 cup (74 g)",
            "200 ml",
            "2 cookies (29 g)"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with specific weight-based serving sizes (in grams)",
              "sql": "SELECT serving_size, product_name FROM products WHERE serving_size LIKE '%g)%' OR serving_size LIKE '%g %' OR serving_size LIKE '% g' LIMIT 50"
            },
            {
              "description": "Analyze distribution of serving size measurement types",
              "sql": "SELECT CASE WHEN serving_size LIKE '%ml%' OR serving_size LIKE '%mL%' THEN 'Volume (ml)' WHEN serving_size LIKE '%g)%' OR serving_size LIKE '%g %' OR serving_size LIKE '% g' THEN 'Weight (g)' WHEN serving_size LIKE '%portion%' OR serving_size LIKE '%serving%' THEN 'Portion-based' ELSE 'Other' END as measurement_type, COUNT(*) as count FROM products WHERE serving_size IS NOT NULL GROUP BY 1 LIMIT 50"
            },
            {
              "description": "Find products with complex serving sizes (multiple units)",
              "sql": "SELECT serving_size, product_name FROM products WHERE serving_size LIKE '%(%' AND (serving_size LIKE '% g %' OR serving_size LIKE '% ml %' OR serving_size LIKE '% mL %') LIMIT 50"
            }
          ]
        },
        "states_tags": {
          "type": "VARCHAR[]",
          "description": "An array of tags indicating the completion status of various product information sections. Each tag starts with 'en:' and indicates whether a specific aspect (like nutrition facts, ingredients, packaging) is completed, to be completed, or needs validation.",
          "examples": [
            "['en:to-be-completed', 'en:nutrition-facts-completed', 'en:ingredients-to-be-completed', 'en:expiration-date-to-be-completed']",
            "['en:to-be-checked', 'en:complete', 'en:nutrition-facts-completed', 'en:ingredients-completed']",
            "['en:to-be-completed', 'en:nutrition-facts-completed', 'en:ingredients-completed', 'en:packaging-completed']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count products by completion status of nutrition facts",
              "sql": "SELECT COUNT(*) as count, list_contains(states_tags, 'en:nutrition-facts-completed') as nutrition_completed FROM products GROUP BY nutrition_completed LIMIT 50"
            },
            {
              "description": "Find products with all main sections completed",
              "sql": "SELECT code, product_name FROM products WHERE list_contains(states_tags, 'en:nutrition-facts-completed') AND list_contains(states_tags, 'en:ingredients-completed') AND list_contains(states_tags, 'en:packaging-completed') LIMIT 50"
            },
            {
              "description": "Get the distribution of most common state tag combinations",
              "sql": "SELECT states_tags, COUNT(*) as frequency FROM products GROUP BY states_tags ORDER BY frequency DESC LIMIT 50"
            }
          ]
        },
        "stores": {
          "type": "VARCHAR",
          "description": "Comma-separated list of retail stores where the product can be found. Includes major Canadian retailers, pharmacies, and specialty stores. Store names may have variations in formatting (e.g., 'SaveOn Foods' vs 'Save-On-Foods').",
          "examples": [
            "Safeway,Shopper's Drug Mart",
            "Costco,Walmart,Real Canadian Superstore,Safeway,Shopper's Drug Mart",
            "London Drugs,Save-On-Foods,Loblaws,Safeway,Sobeys"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products available in a specific store (case-insensitive search)",
              "sql": "SELECT code, product_name, stores FROM products WHERE stores ILIKE '%Walmart%' LIMIT 50;"
            },
            {
              "description": "Find products available in multiple stores (sorted by number of stores)",
              "sql": "SELECT code, product_name, stores, (LENGTH(stores) - LENGTH(REPLACE(stores, ',', ''))) + 1 as store_count FROM products WHERE stores IS NOT NULL ORDER BY store_count DESC LIMIT 50;"
            },
            {
              "description": "Find products available in both specific stores",
              "sql": "SELECT code, product_name, stores FROM products WHERE stores ILIKE '%Walmart%' AND stores ILIKE '%Costco%' LIMIT 50;"
            }
          ]
        },
        "stores_tags": {
          "type": "VARCHAR[]",
          "description": "An array of store identifiers where the product can be found. Contains normalized store names (lowercase, hyphenated). Common stores include major retailers like Walmart, Safeway, and Costco. Most products are found in 1-3 stores, though some can be found in up to 24 stores.",
          "examples": [
            [
              "walmart",
              "maxi",
              "costco",
              "provigo"
            ],
            [
              "safeway"
            ],
            [
              "tang-freres",
              "costco",
              "kim-phat"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products available in specific store (e.g., Walmart)",
              "sql": "SELECT code, product_name, stores_tags FROM products WHERE list_contains(stores_tags, 'walmart') LIMIT 50"
            },
            {
              "description": "Find products available in multiple stores (e.g., both Walmart and Costco)",
              "sql": "SELECT code, product_name, stores_tags FROM products WHERE list_contains(stores_tags, 'walmart') AND list_contains(stores_tags, 'costco') LIMIT 50"
            },
            {
              "description": "Get distribution of products by number of stores they're available in",
              "sql": "SELECT ARRAY_LENGTH(stores_tags) as store_count, COUNT(*) as product_count FROM products WHERE stores_tags IS NOT NULL GROUP BY ARRAY_LENGTH(stores_tags) ORDER BY store_count LIMIT 50"
            }
          ]
        },
        "unique_scans_n": {
          "type": "INTEGER",
          "description": "Number of unique scans a product has received from users. Represents the number of different times a product's barcode has been scanned in the Open Food Facts database. Higher values indicate more frequently scanned products.",
          "examples": [
            "560",
            "464",
            "435"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find the most scanned products (most popular)",
              "sql": "SELECT code, product_name, unique_scans_n FROM products WHERE unique_scans_n IS NOT NULL ORDER BY unique_scans_n DESC LIMIT 50"
            },
            {
              "description": "Get distribution of products by scan frequency ranges",
              "sql": "SELECT CASE WHEN unique_scans_n <= 10 THEN '1-10' WHEN unique_scans_n <= 50 THEN '11-50' WHEN unique_scans_n <= 100 THEN '51-100' ELSE '100+' END as scan_range, COUNT(*) as product_count FROM products WHERE unique_scans_n IS NOT NULL GROUP BY scan_range LIMIT 50"
            },
            {
              "description": "Find products with no scans (potentially new or uncommon products)",
              "sql": "SELECT code, product_name, COALESCE(unique_scans_n, 0) as scan_count FROM products WHERE unique_scans_n IS NULL OR unique_scans_n = 0 LIMIT 50"
            }
          ]
        },
        "unknown_ingredients_n": {
          "type": "INTEGER",
          "description": "Count of ingredients in the product that are not recognized or cannot be properly classified in the Open Food Facts database",
          "examples": [
            "0",
            "1",
            "15"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products with a high number of unknown ingredients (more than 10)",
              "sql": "SELECT code, product_name, unknown_ingredients_n FROM products WHERE unknown_ingredients_n > 10 ORDER BY unknown_ingredients_n DESC LIMIT 50"
            },
            {
              "description": "Calculate the percentage of products with unknown ingredients",
              "sql": "SELECT ROUND(COUNT(CASE WHEN unknown_ingredients_n > 0 THEN 1 END) * 100.0 / COUNT(*), 2) as percent_with_unknown FROM products WHERE unknown_ingredients_n IS NOT NULL LIMIT 50"
            },
            {
              "description": "Group products by ranges of unknown ingredients count",
              "sql": "SELECT CASE WHEN unknown_ingredients_n = 0 THEN 'No unknown' WHEN unknown_ingredients_n BETWEEN 1 AND 5 THEN '1-5' WHEN unknown_ingredients_n BETWEEN 6 AND 10 THEN '6-10' ELSE 'More than 10' END as range, COUNT(*) as count FROM products WHERE unknown_ingredients_n IS NOT NULL GROUP BY 1 LIMIT 50"
            }
          ]
        },
        "unknown_nutrients_tags": {
          "type": "VARCHAR[]",
          "description": "Array of tags representing nutrients or compounds that are mentioned on the product but not standardized in the database. Tags are usually prefixed with language codes (e.g., 'fr-', 'en-', 'es-') and can include various supplements, additives, or uncommon nutrients.",
          "examples": [
            [
              "fr-creatine"
            ],
            [
              "acide-gras-polyinsatures",
              "acide-gras-satures"
            ],
            [
              "en-citrate",
              "en-galactooligosaccharides"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products containing specific unknown nutrients (e.g., creatine)",
              "sql": "SELECT code, product_name, unknown_nutrients_tags FROM products WHERE list_contains(unknown_nutrients_tags, 'fr-creatine') LIMIT 50"
            },
            {
              "description": "Get products with multiple unknown nutrients (more than 2)",
              "sql": "SELECT code, product_name, unknown_nutrients_tags FROM products WHERE array_length(unknown_nutrients_tags) > 2 ORDER BY array_length(unknown_nutrients_tags) DESC LIMIT 50"
            },
            {
              "description": "Find products with English-tagged unknown nutrients",
              "sql": "SELECT code, product_name, unknown_nutrients_tags FROM products WHERE array_contains(array_filter(unknown_nutrients_tags, x -> x LIKE 'en-%')) LIMIT 50"
            }
          ]
        },
        "traces_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized tags indicating potential allergen traces in the product. Each tag uses a language prefix (e.g., 'en:' for English) followed by the allergen name. Common allergens include milk, nuts, gluten, eggs, and soybeans.",
          "examples": [
            [
              "en:eggs",
              "en:milk",
              "en:nuts",
              "fr:coconut"
            ],
            [
              "en:gluten",
              "en:milk",
              "en:mustard"
            ],
            [
              "en:eggs",
              "en:nuts",
              "en:peanuts",
              "en:sesame-seeds",
              "en:soybeans"
            ]
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products that may contain both milk and nuts traces",
              "sql": "SELECT code, product_name, traces_tags FROM products WHERE traces_tags IS NOT NULL AND list_contains(traces_tags, 'en:milk') AND list_contains(traces_tags, 'en:nuts') LIMIT 50"
            },
            {
              "description": "Get products grouped by number of potential allergen traces",
              "sql": "SELECT array_length(traces_tags) as allergen_count, COUNT(*) as product_count FROM products WHERE traces_tags IS NOT NULL GROUP BY array_length(traces_tags) ORDER BY allergen_count LIMIT 50"
            },
            {
              "description": "Find products with no allergen traces",
              "sql": "SELECT code, product_name FROM products WHERE traces_tags IS NULL OR array_length(traces_tags) = 0 LIMIT 50"
            }
          ]
        },
        "vitamins_tags": {
          "type": "VARCHAR[]",
          "description": "An array of standardized vitamin identifiers present in the food product. Each vitamin is prefixed with 'en:' and uses scientific names (e.g., 'en:l-ascorbic-acid' for Vitamin C).",
          "examples": [
            "['en:niacin', 'en:thiamin-mononitrate', 'en:riboflavin', 'en:folic-acid']",
            "['en:vitamin-e', 'en:vitamin-c', 'en:vitamin-b6', 'en:pyridoxine-hydrochloride', 'en:riboflavin']",
            "['en:l-ascorbic-acid', 'en:riboflavin', 'en:niacin', 'en:folic-acid']"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Find products containing Vitamin C (l-ascorbic-acid) and count them",
              "sql": "SELECT COUNT(*) as products_with_vitamin_c FROM products WHERE list_contains(vitamins_tags, 'en:l-ascorbic-acid') OR list_contains(vitamins_tags, 'en:vitamin-c') LIMIT 50"
            },
            {
              "description": "Get the distribution of the most common vitamins in products",
              "sql": "WITH RECURSIVE unnested AS (SELECT UNNEST(vitamins_tags) as vitamin FROM products WHERE vitamins_tags IS NOT NULL) SELECT vitamin, COUNT(*) as count FROM unnested GROUP BY vitamin ORDER BY count DESC LIMIT 50"
            },
            {
              "description": "Find products with the highest vitamin variety (most vitamins listed)",
              "sql": "SELECT code, product_name, array_length(vitamins_tags) as vitamin_count, vitamins_tags FROM products WHERE vitamins_tags IS NOT NULL ORDER BY array_length(vitamins_tags) DESC LIMIT 50"
            }
          ]
        },
        "with_non_nutritive_sweeteners": {
          "type": "INTEGER",
          "description": "Binary flag indicating whether a product contains non-nutritive (artificial) sweeteners. Value 1 indicates presence of sweeteners, NULL typically indicates unknown status.",
          "examples": [
            "1",
            "NULL",
            "NULL"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count of products by sweetener status",
              "sql": "SELECT CASE WHEN with_non_nutritive_sweeteners = 1 THEN 'Contains sweeteners' WHEN with_non_nutritive_sweeteners = 0 THEN 'No sweeteners' ELSE 'Unknown' END as status, COUNT(*) as count FROM products GROUP BY 1 LIMIT 50"
            },
            {
              "description": "List products containing non-nutritive sweeteners",
              "sql": "SELECT code, product_name FROM products WHERE with_non_nutritive_sweeteners = 1 ORDER BY code LIMIT 50"
            },
            {
              "description": "Percentage of products with known sweetener status",
              "sql": "SELECT ROUND(COUNT(CASE WHEN with_non_nutritive_sweeteners IS NOT NULL THEN 1 END) * 100.0 / COUNT(*), 2) as percentage_known FROM products LIMIT 50"
            }
          ]
        },
        "with_sweeteners": {
          "type": "INTEGER",
          "description": "Boolean flag (0/1) indicating whether the product contains artificial sweeteners or sugar substitutes. Value of 1 indicates presence of sweeteners like aspartame, sorbitol, xylitol, etc. NULL or 0 indicates no sweeteners.",
          "examples": [
            "1",
            "1",
            "1"
          ],
          "is_nullable": true,
          "common_queries": [
            {
              "description": "Count of products with and without sweeteners",
              "sql": "SELECT CASE WHEN with_sweeteners = 1 THEN 'With sweeteners' ELSE 'Without sweeteners' END as category, COUNT(*) as count FROM products GROUP BY with_sweeteners LIMIT 50"
            },
            {
              "description": "Find products containing sweeteners and their ingredients",
              "sql": "SELECT code, product_name, ingredients_text FROM products WHERE with_sweeteners = 1 ORDER BY code LIMIT 50"
            },
            {
              "description": "Compare the percentage of products with sweeteners by product category",
              "sql": "SELECT categories_tags, COUNT(*) as total_products, SUM(CASE WHEN with_sweeteners = 1 THEN 1 ELSE 0 END) as with_sweeteners_count, ROUND(100.0 * SUM(CASE WHEN with_sweeteners = 1 THEN 1 ELSE 0 END) / COUNT(*), 2) as sweetener_percentage FROM products GROUP BY categories_tags ORDER BY sweetener_percentage DESC LIMIT 50"
            }
          ]
        }
      }
    }
  }
}